// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: commands.proto

package messages

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type FeaturesOrderType int32

const (
	FeaturesOrderType_ORDER_OF_DEFINITION FeaturesOrderType = 0
	FeaturesOrderType_RANDOM              FeaturesOrderType = 1
)

var FeaturesOrderType_name = map[int32]string{
	0: "ORDER_OF_DEFINITION",
	1: "RANDOM",
}
var FeaturesOrderType_value = map[string]int32{
	"ORDER_OF_DEFINITION": 0,
	"RANDOM":              1,
}

func (x FeaturesOrderType) String() string {
	return proto.EnumName(FeaturesOrderType_name, int32(x))
}
func (FeaturesOrderType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_commands_f6a80ffcac567fa6, []int{0}
}

type StepDefinitionPatternType int32

const (
	StepDefinitionPatternType_CUCUMBER_EXPRESSION StepDefinitionPatternType = 0
	StepDefinitionPatternType_REGULAR_EXPRESSION  StepDefinitionPatternType = 1
)

var StepDefinitionPatternType_name = map[int32]string{
	0: "CUCUMBER_EXPRESSION",
	1: "REGULAR_EXPRESSION",
}
var StepDefinitionPatternType_value = map[string]int32{
	"CUCUMBER_EXPRESSION": 0,
	"REGULAR_EXPRESSION":  1,
}

func (x StepDefinitionPatternType) String() string {
	return proto.EnumName(StepDefinitionPatternType_name, int32(x))
}
func (StepDefinitionPatternType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_commands_f6a80ffcac567fa6, []int{1}
}

// All messages sent between cucumber-engine and its calling process must be of type CommandWrapper
type CommandWrapper struct {
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Types that are valid to be assigned to Message:
	//	*CommandWrapper_CommandStart
	//	*CommandWrapper_CommandActionComplete
	//	*CommandWrapper_CommandRunBeforeTestRunHooks
	//	*CommandWrapper_CommandInitializeTestCase
	//	*CommandWrapper_CommandRunBeforeTestCaseHook
	//	*CommandWrapper_CommandRunTestStep
	//	*CommandWrapper_CommandRunAfterTestCaseHook
	//	*CommandWrapper_CommandRunAfterTestRunHooks
	//	*CommandWrapper_CommandGenerateSnippet
	//	*CommandWrapper_CommandEvent
	//	*CommandWrapper_CommandError
	Message isCommandWrapper_Message `protobuf_oneof:"message"`
}

func (m *CommandWrapper) Reset()         { *m = CommandWrapper{} }
func (m *CommandWrapper) String() string { return proto.CompactTextString(m) }
func (*CommandWrapper) ProtoMessage()    {}
func (*CommandWrapper) Descriptor() ([]byte, []int) {
	return fileDescriptor_commands_f6a80ffcac567fa6, []int{0}
}
func (m *CommandWrapper) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandWrapper) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandWrapper.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CommandWrapper) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandWrapper.Merge(dst, src)
}
func (m *CommandWrapper) XXX_Size() int {
	return m.Size()
}
func (m *CommandWrapper) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandWrapper.DiscardUnknown(m)
}

var xxx_messageInfo_CommandWrapper proto.InternalMessageInfo

type isCommandWrapper_Message interface {
	isCommandWrapper_Message()
	MarshalTo([]byte) (int, error)
	Size() int
}

type CommandWrapper_CommandStart struct {
	CommandStart *CommandStart `protobuf:"bytes,2,opt,name=commandStart,oneof"`
}
type CommandWrapper_CommandActionComplete struct {
	CommandActionComplete *CommandActionComplete `protobuf:"bytes,3,opt,name=commandActionComplete,oneof"`
}
type CommandWrapper_CommandRunBeforeTestRunHooks struct {
	CommandRunBeforeTestRunHooks *CommandRunBeforeTestRunHooks `protobuf:"bytes,4,opt,name=commandRunBeforeTestRunHooks,oneof"`
}
type CommandWrapper_CommandInitializeTestCase struct {
	CommandInitializeTestCase *CommandInitializeTestCase `protobuf:"bytes,5,opt,name=commandInitializeTestCase,oneof"`
}
type CommandWrapper_CommandRunBeforeTestCaseHook struct {
	CommandRunBeforeTestCaseHook *CommandRunBeforeTestCaseHook `protobuf:"bytes,6,opt,name=commandRunBeforeTestCaseHook,oneof"`
}
type CommandWrapper_CommandRunTestStep struct {
	CommandRunTestStep *CommandRunTestStep `protobuf:"bytes,7,opt,name=commandRunTestStep,oneof"`
}
type CommandWrapper_CommandRunAfterTestCaseHook struct {
	CommandRunAfterTestCaseHook *CommandRunAfterTestCaseHook `protobuf:"bytes,8,opt,name=commandRunAfterTestCaseHook,oneof"`
}
type CommandWrapper_CommandRunAfterTestRunHooks struct {
	CommandRunAfterTestRunHooks *CommandRunAfterTestRunHooks `protobuf:"bytes,9,opt,name=commandRunAfterTestRunHooks,oneof"`
}
type CommandWrapper_CommandGenerateSnippet struct {
	CommandGenerateSnippet *CommandGenerateSnippet `protobuf:"bytes,10,opt,name=commandGenerateSnippet,oneof"`
}
type CommandWrapper_CommandEvent struct {
	CommandEvent *EventWrapper `protobuf:"bytes,11,opt,name=commandEvent,oneof"`
}
type CommandWrapper_CommandError struct {
	CommandError string `protobuf:"bytes,12,opt,name=commandError,proto3,oneof"`
}

func (*CommandWrapper_CommandStart) isCommandWrapper_Message()                 {}
func (*CommandWrapper_CommandActionComplete) isCommandWrapper_Message()        {}
func (*CommandWrapper_CommandRunBeforeTestRunHooks) isCommandWrapper_Message() {}
func (*CommandWrapper_CommandInitializeTestCase) isCommandWrapper_Message()    {}
func (*CommandWrapper_CommandRunBeforeTestCaseHook) isCommandWrapper_Message() {}
func (*CommandWrapper_CommandRunTestStep) isCommandWrapper_Message()           {}
func (*CommandWrapper_CommandRunAfterTestCaseHook) isCommandWrapper_Message()  {}
func (*CommandWrapper_CommandRunAfterTestRunHooks) isCommandWrapper_Message()  {}
func (*CommandWrapper_CommandGenerateSnippet) isCommandWrapper_Message()       {}
func (*CommandWrapper_CommandEvent) isCommandWrapper_Message()                 {}
func (*CommandWrapper_CommandError) isCommandWrapper_Message()                 {}

func (m *CommandWrapper) GetMessage() isCommandWrapper_Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *CommandWrapper) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CommandWrapper) GetCommandStart() *CommandStart {
	if x, ok := m.GetMessage().(*CommandWrapper_CommandStart); ok {
		return x.CommandStart
	}
	return nil
}

func (m *CommandWrapper) GetCommandActionComplete() *CommandActionComplete {
	if x, ok := m.GetMessage().(*CommandWrapper_CommandActionComplete); ok {
		return x.CommandActionComplete
	}
	return nil
}

func (m *CommandWrapper) GetCommandRunBeforeTestRunHooks() *CommandRunBeforeTestRunHooks {
	if x, ok := m.GetMessage().(*CommandWrapper_CommandRunBeforeTestRunHooks); ok {
		return x.CommandRunBeforeTestRunHooks
	}
	return nil
}

func (m *CommandWrapper) GetCommandInitializeTestCase() *CommandInitializeTestCase {
	if x, ok := m.GetMessage().(*CommandWrapper_CommandInitializeTestCase); ok {
		return x.CommandInitializeTestCase
	}
	return nil
}

func (m *CommandWrapper) GetCommandRunBeforeTestCaseHook() *CommandRunBeforeTestCaseHook {
	if x, ok := m.GetMessage().(*CommandWrapper_CommandRunBeforeTestCaseHook); ok {
		return x.CommandRunBeforeTestCaseHook
	}
	return nil
}

func (m *CommandWrapper) GetCommandRunTestStep() *CommandRunTestStep {
	if x, ok := m.GetMessage().(*CommandWrapper_CommandRunTestStep); ok {
		return x.CommandRunTestStep
	}
	return nil
}

func (m *CommandWrapper) GetCommandRunAfterTestCaseHook() *CommandRunAfterTestCaseHook {
	if x, ok := m.GetMessage().(*CommandWrapper_CommandRunAfterTestCaseHook); ok {
		return x.CommandRunAfterTestCaseHook
	}
	return nil
}

func (m *CommandWrapper) GetCommandRunAfterTestRunHooks() *CommandRunAfterTestRunHooks {
	if x, ok := m.GetMessage().(*CommandWrapper_CommandRunAfterTestRunHooks); ok {
		return x.CommandRunAfterTestRunHooks
	}
	return nil
}

func (m *CommandWrapper) GetCommandGenerateSnippet() *CommandGenerateSnippet {
	if x, ok := m.GetMessage().(*CommandWrapper_CommandGenerateSnippet); ok {
		return x.CommandGenerateSnippet
	}
	return nil
}

func (m *CommandWrapper) GetCommandEvent() *EventWrapper {
	if x, ok := m.GetMessage().(*CommandWrapper_CommandEvent); ok {
		return x.CommandEvent
	}
	return nil
}

func (m *CommandWrapper) GetCommandError() string {
	if x, ok := m.GetMessage().(*CommandWrapper_CommandError); ok {
		return x.CommandError
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CommandWrapper) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CommandWrapper_OneofMarshaler, _CommandWrapper_OneofUnmarshaler, _CommandWrapper_OneofSizer, []interface{}{
		(*CommandWrapper_CommandStart)(nil),
		(*CommandWrapper_CommandActionComplete)(nil),
		(*CommandWrapper_CommandRunBeforeTestRunHooks)(nil),
		(*CommandWrapper_CommandInitializeTestCase)(nil),
		(*CommandWrapper_CommandRunBeforeTestCaseHook)(nil),
		(*CommandWrapper_CommandRunTestStep)(nil),
		(*CommandWrapper_CommandRunAfterTestCaseHook)(nil),
		(*CommandWrapper_CommandRunAfterTestRunHooks)(nil),
		(*CommandWrapper_CommandGenerateSnippet)(nil),
		(*CommandWrapper_CommandEvent)(nil),
		(*CommandWrapper_CommandError)(nil),
	}
}

func _CommandWrapper_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CommandWrapper)
	// message
	switch x := m.Message.(type) {
	case *CommandWrapper_CommandStart:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CommandStart); err != nil {
			return err
		}
	case *CommandWrapper_CommandActionComplete:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CommandActionComplete); err != nil {
			return err
		}
	case *CommandWrapper_CommandRunBeforeTestRunHooks:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CommandRunBeforeTestRunHooks); err != nil {
			return err
		}
	case *CommandWrapper_CommandInitializeTestCase:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CommandInitializeTestCase); err != nil {
			return err
		}
	case *CommandWrapper_CommandRunBeforeTestCaseHook:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CommandRunBeforeTestCaseHook); err != nil {
			return err
		}
	case *CommandWrapper_CommandRunTestStep:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CommandRunTestStep); err != nil {
			return err
		}
	case *CommandWrapper_CommandRunAfterTestCaseHook:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CommandRunAfterTestCaseHook); err != nil {
			return err
		}
	case *CommandWrapper_CommandRunAfterTestRunHooks:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CommandRunAfterTestRunHooks); err != nil {
			return err
		}
	case *CommandWrapper_CommandGenerateSnippet:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CommandGenerateSnippet); err != nil {
			return err
		}
	case *CommandWrapper_CommandEvent:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CommandEvent); err != nil {
			return err
		}
	case *CommandWrapper_CommandError:
		_ = b.EncodeVarint(12<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.CommandError)
	case nil:
	default:
		return fmt.Errorf("CommandWrapper.Message has unexpected type %T", x)
	}
	return nil
}

func _CommandWrapper_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CommandWrapper)
	switch tag {
	case 2: // message.commandStart
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommandStart)
		err := b.DecodeMessage(msg)
		m.Message = &CommandWrapper_CommandStart{msg}
		return true, err
	case 3: // message.commandActionComplete
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommandActionComplete)
		err := b.DecodeMessage(msg)
		m.Message = &CommandWrapper_CommandActionComplete{msg}
		return true, err
	case 4: // message.commandRunBeforeTestRunHooks
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommandRunBeforeTestRunHooks)
		err := b.DecodeMessage(msg)
		m.Message = &CommandWrapper_CommandRunBeforeTestRunHooks{msg}
		return true, err
	case 5: // message.commandInitializeTestCase
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommandInitializeTestCase)
		err := b.DecodeMessage(msg)
		m.Message = &CommandWrapper_CommandInitializeTestCase{msg}
		return true, err
	case 6: // message.commandRunBeforeTestCaseHook
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommandRunBeforeTestCaseHook)
		err := b.DecodeMessage(msg)
		m.Message = &CommandWrapper_CommandRunBeforeTestCaseHook{msg}
		return true, err
	case 7: // message.commandRunTestStep
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommandRunTestStep)
		err := b.DecodeMessage(msg)
		m.Message = &CommandWrapper_CommandRunTestStep{msg}
		return true, err
	case 8: // message.commandRunAfterTestCaseHook
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommandRunAfterTestCaseHook)
		err := b.DecodeMessage(msg)
		m.Message = &CommandWrapper_CommandRunAfterTestCaseHook{msg}
		return true, err
	case 9: // message.commandRunAfterTestRunHooks
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommandRunAfterTestRunHooks)
		err := b.DecodeMessage(msg)
		m.Message = &CommandWrapper_CommandRunAfterTestRunHooks{msg}
		return true, err
	case 10: // message.commandGenerateSnippet
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommandGenerateSnippet)
		err := b.DecodeMessage(msg)
		m.Message = &CommandWrapper_CommandGenerateSnippet{msg}
		return true, err
	case 11: // message.commandEvent
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EventWrapper)
		err := b.DecodeMessage(msg)
		m.Message = &CommandWrapper_CommandEvent{msg}
		return true, err
	case 12: // message.commandError
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Message = &CommandWrapper_CommandError{x}
		return true, err
	default:
		return false, nil
	}
}

func _CommandWrapper_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CommandWrapper)
	// message
	switch x := m.Message.(type) {
	case *CommandWrapper_CommandStart:
		s := proto.Size(x.CommandStart)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CommandWrapper_CommandActionComplete:
		s := proto.Size(x.CommandActionComplete)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CommandWrapper_CommandRunBeforeTestRunHooks:
		s := proto.Size(x.CommandRunBeforeTestRunHooks)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CommandWrapper_CommandInitializeTestCase:
		s := proto.Size(x.CommandInitializeTestCase)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CommandWrapper_CommandRunBeforeTestCaseHook:
		s := proto.Size(x.CommandRunBeforeTestCaseHook)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CommandWrapper_CommandRunTestStep:
		s := proto.Size(x.CommandRunTestStep)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CommandWrapper_CommandRunAfterTestCaseHook:
		s := proto.Size(x.CommandRunAfterTestCaseHook)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CommandWrapper_CommandRunAfterTestRunHooks:
		s := proto.Size(x.CommandRunAfterTestRunHooks)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CommandWrapper_CommandGenerateSnippet:
		s := proto.Size(x.CommandGenerateSnippet)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CommandWrapper_CommandEvent:
		s := proto.Size(x.CommandEvent)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CommandWrapper_CommandError:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.CommandError)))
		n += len(x.CommandError)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type CommandStart struct {
	BaseDirectory     string             `protobuf:"bytes,2,opt,name=baseDirectory,proto3" json:"baseDirectory,omitempty"`
	FeaturesConfig    *FeaturesConfig    `protobuf:"bytes,3,opt,name=featuresConfig" json:"featuresConfig,omitempty"`
	RuntimeConfig     *RuntimeConfig     `protobuf:"bytes,4,opt,name=runtimeConfig" json:"runtimeConfig,omitempty"`
	SupportCodeConfig *SupportCodeConfig `protobuf:"bytes,5,opt,name=supportCodeConfig" json:"supportCodeConfig,omitempty"`
}

func (m *CommandStart) Reset()         { *m = CommandStart{} }
func (m *CommandStart) String() string { return proto.CompactTextString(m) }
func (*CommandStart) ProtoMessage()    {}
func (*CommandStart) Descriptor() ([]byte, []int) {
	return fileDescriptor_commands_f6a80ffcac567fa6, []int{1}
}
func (m *CommandStart) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandStart) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandStart.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CommandStart) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandStart.Merge(dst, src)
}
func (m *CommandStart) XXX_Size() int {
	return m.Size()
}
func (m *CommandStart) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandStart.DiscardUnknown(m)
}

var xxx_messageInfo_CommandStart proto.InternalMessageInfo

func (m *CommandStart) GetBaseDirectory() string {
	if m != nil {
		return m.BaseDirectory
	}
	return ""
}

func (m *CommandStart) GetFeaturesConfig() *FeaturesConfig {
	if m != nil {
		return m.FeaturesConfig
	}
	return nil
}

func (m *CommandStart) GetRuntimeConfig() *RuntimeConfig {
	if m != nil {
		return m.RuntimeConfig
	}
	return nil
}

func (m *CommandStart) GetSupportCodeConfig() *SupportCodeConfig {
	if m != nil {
		return m.SupportCodeConfig
	}
	return nil
}

type FeaturesConfig struct {
	AbsolutePaths []string              `protobuf:"bytes,1,rep,name=absolutePaths" json:"absolutePaths,omitempty"`
	Language      string                `protobuf:"bytes,2,opt,name=language,proto3" json:"language,omitempty"`
	Filters       *FeaturesFilterConfig `protobuf:"bytes,3,opt,name=filters" json:"filters,omitempty"`
	Order         *FeaturesOrder        `protobuf:"bytes,4,opt,name=order" json:"order,omitempty"`
}

func (m *FeaturesConfig) Reset()         { *m = FeaturesConfig{} }
func (m *FeaturesConfig) String() string { return proto.CompactTextString(m) }
func (*FeaturesConfig) ProtoMessage()    {}
func (*FeaturesConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_commands_f6a80ffcac567fa6, []int{2}
}
func (m *FeaturesConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeaturesConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeaturesConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FeaturesConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeaturesConfig.Merge(dst, src)
}
func (m *FeaturesConfig) XXX_Size() int {
	return m.Size()
}
func (m *FeaturesConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_FeaturesConfig.DiscardUnknown(m)
}

var xxx_messageInfo_FeaturesConfig proto.InternalMessageInfo

func (m *FeaturesConfig) GetAbsolutePaths() []string {
	if m != nil {
		return m.AbsolutePaths
	}
	return nil
}

func (m *FeaturesConfig) GetLanguage() string {
	if m != nil {
		return m.Language
	}
	return ""
}

func (m *FeaturesConfig) GetFilters() *FeaturesFilterConfig {
	if m != nil {
		return m.Filters
	}
	return nil
}

func (m *FeaturesConfig) GetOrder() *FeaturesOrder {
	if m != nil {
		return m.Order
	}
	return nil
}

type FeaturesFilterConfig struct {
	TagExpression          string               `protobuf:"bytes,1,opt,name=tagExpression,proto3" json:"tagExpression,omitempty"`
	NameRegularExpressions []string             `protobuf:"bytes,2,rep,name=nameRegularExpressions" json:"nameRegularExpressions,omitempty"`
	UriToLinesMapping      []*UriToLinesMapping `protobuf:"bytes,3,rep,name=uriToLinesMapping" json:"uriToLinesMapping,omitempty"`
}

func (m *FeaturesFilterConfig) Reset()         { *m = FeaturesFilterConfig{} }
func (m *FeaturesFilterConfig) String() string { return proto.CompactTextString(m) }
func (*FeaturesFilterConfig) ProtoMessage()    {}
func (*FeaturesFilterConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_commands_f6a80ffcac567fa6, []int{3}
}
func (m *FeaturesFilterConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeaturesFilterConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeaturesFilterConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FeaturesFilterConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeaturesFilterConfig.Merge(dst, src)
}
func (m *FeaturesFilterConfig) XXX_Size() int {
	return m.Size()
}
func (m *FeaturesFilterConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_FeaturesFilterConfig.DiscardUnknown(m)
}

var xxx_messageInfo_FeaturesFilterConfig proto.InternalMessageInfo

func (m *FeaturesFilterConfig) GetTagExpression() string {
	if m != nil {
		return m.TagExpression
	}
	return ""
}

func (m *FeaturesFilterConfig) GetNameRegularExpressions() []string {
	if m != nil {
		return m.NameRegularExpressions
	}
	return nil
}

func (m *FeaturesFilterConfig) GetUriToLinesMapping() []*UriToLinesMapping {
	if m != nil {
		return m.UriToLinesMapping
	}
	return nil
}

type UriToLinesMapping struct {
	AbsolutePath string   `protobuf:"bytes,1,opt,name=absolutePath,proto3" json:"absolutePath,omitempty"`
	Lines        []uint64 `protobuf:"varint,2,rep,packed,name=lines" json:"lines,omitempty"`
}

func (m *UriToLinesMapping) Reset()         { *m = UriToLinesMapping{} }
func (m *UriToLinesMapping) String() string { return proto.CompactTextString(m) }
func (*UriToLinesMapping) ProtoMessage()    {}
func (*UriToLinesMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_commands_f6a80ffcac567fa6, []int{4}
}
func (m *UriToLinesMapping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UriToLinesMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UriToLinesMapping.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UriToLinesMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UriToLinesMapping.Merge(dst, src)
}
func (m *UriToLinesMapping) XXX_Size() int {
	return m.Size()
}
func (m *UriToLinesMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_UriToLinesMapping.DiscardUnknown(m)
}

var xxx_messageInfo_UriToLinesMapping proto.InternalMessageInfo

func (m *UriToLinesMapping) GetAbsolutePath() string {
	if m != nil {
		return m.AbsolutePath
	}
	return ""
}

func (m *UriToLinesMapping) GetLines() []uint64 {
	if m != nil {
		return m.Lines
	}
	return nil
}

type FeaturesOrder struct {
	Type FeaturesOrderType `protobuf:"varint,1,opt,name=type,proto3,enum=io.cucumber.messages.FeaturesOrderType" json:"type,omitempty"`
	Seed uint64            `protobuf:"varint,2,opt,name=seed,proto3" json:"seed,omitempty"`
}

func (m *FeaturesOrder) Reset()         { *m = FeaturesOrder{} }
func (m *FeaturesOrder) String() string { return proto.CompactTextString(m) }
func (*FeaturesOrder) ProtoMessage()    {}
func (*FeaturesOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_commands_f6a80ffcac567fa6, []int{5}
}
func (m *FeaturesOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeaturesOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeaturesOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FeaturesOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeaturesOrder.Merge(dst, src)
}
func (m *FeaturesOrder) XXX_Size() int {
	return m.Size()
}
func (m *FeaturesOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_FeaturesOrder.DiscardUnknown(m)
}

var xxx_messageInfo_FeaturesOrder proto.InternalMessageInfo

func (m *FeaturesOrder) GetType() FeaturesOrderType {
	if m != nil {
		return m.Type
	}
	return FeaturesOrderType_ORDER_OF_DEFINITION
}

func (m *FeaturesOrder) GetSeed() uint64 {
	if m != nil {
		return m.Seed
	}
	return 0
}

type RuntimeConfig struct {
	IsFailFast  bool   `protobuf:"varint,1,opt,name=isFailFast,proto3" json:"isFailFast,omitempty"`
	IsDryRun    bool   `protobuf:"varint,2,opt,name=isDryRun,proto3" json:"isDryRun,omitempty"`
	IsStrict    bool   `protobuf:"varint,3,opt,name=isStrict,proto3" json:"isStrict,omitempty"`
	MaxParallel uint64 `protobuf:"varint,4,opt,name=maxParallel,proto3" json:"maxParallel,omitempty"`
}

func (m *RuntimeConfig) Reset()         { *m = RuntimeConfig{} }
func (m *RuntimeConfig) String() string { return proto.CompactTextString(m) }
func (*RuntimeConfig) ProtoMessage()    {}
func (*RuntimeConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_commands_f6a80ffcac567fa6, []int{6}
}
func (m *RuntimeConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RuntimeConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RuntimeConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RuntimeConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RuntimeConfig.Merge(dst, src)
}
func (m *RuntimeConfig) XXX_Size() int {
	return m.Size()
}
func (m *RuntimeConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_RuntimeConfig.DiscardUnknown(m)
}

var xxx_messageInfo_RuntimeConfig proto.InternalMessageInfo

func (m *RuntimeConfig) GetIsFailFast() bool {
	if m != nil {
		return m.IsFailFast
	}
	return false
}

func (m *RuntimeConfig) GetIsDryRun() bool {
	if m != nil {
		return m.IsDryRun
	}
	return false
}

func (m *RuntimeConfig) GetIsStrict() bool {
	if m != nil {
		return m.IsStrict
	}
	return false
}

func (m *RuntimeConfig) GetMaxParallel() uint64 {
	if m != nil {
		return m.MaxParallel
	}
	return 0
}

type SupportCodeConfig struct {
	BeforeTestCaseHookDefinitionConfigs []*TestCaseHookDefinitionConfig `protobuf:"bytes,1,rep,name=beforeTestCaseHookDefinitionConfigs" json:"beforeTestCaseHookDefinitionConfigs,omitempty"`
	AfterTestCaseHookDefinitionConfigs  []*TestCaseHookDefinitionConfig `protobuf:"bytes,2,rep,name=afterTestCaseHookDefinitionConfigs" json:"afterTestCaseHookDefinitionConfigs,omitempty"`
	StepDefinitionConfigs               []*StepDefinitionConfig         `protobuf:"bytes,3,rep,name=stepDefinitionConfigs" json:"stepDefinitionConfigs,omitempty"`
	ParameterTypeConfigs                []*ParameterTypeConfig          `protobuf:"bytes,4,rep,name=parameterTypeConfigs" json:"parameterTypeConfigs,omitempty"`
}

func (m *SupportCodeConfig) Reset()         { *m = SupportCodeConfig{} }
func (m *SupportCodeConfig) String() string { return proto.CompactTextString(m) }
func (*SupportCodeConfig) ProtoMessage()    {}
func (*SupportCodeConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_commands_f6a80ffcac567fa6, []int{7}
}
func (m *SupportCodeConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SupportCodeConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SupportCodeConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SupportCodeConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SupportCodeConfig.Merge(dst, src)
}
func (m *SupportCodeConfig) XXX_Size() int {
	return m.Size()
}
func (m *SupportCodeConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SupportCodeConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SupportCodeConfig proto.InternalMessageInfo

func (m *SupportCodeConfig) GetBeforeTestCaseHookDefinitionConfigs() []*TestCaseHookDefinitionConfig {
	if m != nil {
		return m.BeforeTestCaseHookDefinitionConfigs
	}
	return nil
}

func (m *SupportCodeConfig) GetAfterTestCaseHookDefinitionConfigs() []*TestCaseHookDefinitionConfig {
	if m != nil {
		return m.AfterTestCaseHookDefinitionConfigs
	}
	return nil
}

func (m *SupportCodeConfig) GetStepDefinitionConfigs() []*StepDefinitionConfig {
	if m != nil {
		return m.StepDefinitionConfigs
	}
	return nil
}

func (m *SupportCodeConfig) GetParameterTypeConfigs() []*ParameterTypeConfig {
	if m != nil {
		return m.ParameterTypeConfigs
	}
	return nil
}

type TestCaseHookDefinitionConfig struct {
	Id            string           `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	TagExpression string           `protobuf:"bytes,2,opt,name=tagExpression,proto3" json:"tagExpression,omitempty"`
	Location      *SourceReference `protobuf:"bytes,3,opt,name=location" json:"location,omitempty"`
}

func (m *TestCaseHookDefinitionConfig) Reset()         { *m = TestCaseHookDefinitionConfig{} }
func (m *TestCaseHookDefinitionConfig) String() string { return proto.CompactTextString(m) }
func (*TestCaseHookDefinitionConfig) ProtoMessage()    {}
func (*TestCaseHookDefinitionConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_commands_f6a80ffcac567fa6, []int{8}
}
func (m *TestCaseHookDefinitionConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestCaseHookDefinitionConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestCaseHookDefinitionConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TestCaseHookDefinitionConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestCaseHookDefinitionConfig.Merge(dst, src)
}
func (m *TestCaseHookDefinitionConfig) XXX_Size() int {
	return m.Size()
}
func (m *TestCaseHookDefinitionConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TestCaseHookDefinitionConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TestCaseHookDefinitionConfig proto.InternalMessageInfo

func (m *TestCaseHookDefinitionConfig) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *TestCaseHookDefinitionConfig) GetTagExpression() string {
	if m != nil {
		return m.TagExpression
	}
	return ""
}

func (m *TestCaseHookDefinitionConfig) GetLocation() *SourceReference {
	if m != nil {
		return m.Location
	}
	return nil
}

type StepDefinitionConfig struct {
	Id       string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Pattern  *StepDefinitionPattern `protobuf:"bytes,2,opt,name=pattern" json:"pattern,omitempty"`
	Location *SourceReference       `protobuf:"bytes,3,opt,name=location" json:"location,omitempty"`
}

func (m *StepDefinitionConfig) Reset()         { *m = StepDefinitionConfig{} }
func (m *StepDefinitionConfig) String() string { return proto.CompactTextString(m) }
func (*StepDefinitionConfig) ProtoMessage()    {}
func (*StepDefinitionConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_commands_f6a80ffcac567fa6, []int{9}
}
func (m *StepDefinitionConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StepDefinitionConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StepDefinitionConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *StepDefinitionConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StepDefinitionConfig.Merge(dst, src)
}
func (m *StepDefinitionConfig) XXX_Size() int {
	return m.Size()
}
func (m *StepDefinitionConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_StepDefinitionConfig.DiscardUnknown(m)
}

var xxx_messageInfo_StepDefinitionConfig proto.InternalMessageInfo

func (m *StepDefinitionConfig) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *StepDefinitionConfig) GetPattern() *StepDefinitionPattern {
	if m != nil {
		return m.Pattern
	}
	return nil
}

func (m *StepDefinitionConfig) GetLocation() *SourceReference {
	if m != nil {
		return m.Location
	}
	return nil
}

type StepDefinitionPattern struct {
	Source string                    `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Type   StepDefinitionPatternType `protobuf:"varint,2,opt,name=type,proto3,enum=io.cucumber.messages.StepDefinitionPatternType" json:"type,omitempty"`
}

func (m *StepDefinitionPattern) Reset()         { *m = StepDefinitionPattern{} }
func (m *StepDefinitionPattern) String() string { return proto.CompactTextString(m) }
func (*StepDefinitionPattern) ProtoMessage()    {}
func (*StepDefinitionPattern) Descriptor() ([]byte, []int) {
	return fileDescriptor_commands_f6a80ffcac567fa6, []int{10}
}
func (m *StepDefinitionPattern) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StepDefinitionPattern) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StepDefinitionPattern.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *StepDefinitionPattern) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StepDefinitionPattern.Merge(dst, src)
}
func (m *StepDefinitionPattern) XXX_Size() int {
	return m.Size()
}
func (m *StepDefinitionPattern) XXX_DiscardUnknown() {
	xxx_messageInfo_StepDefinitionPattern.DiscardUnknown(m)
}

var xxx_messageInfo_StepDefinitionPattern proto.InternalMessageInfo

func (m *StepDefinitionPattern) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *StepDefinitionPattern) GetType() StepDefinitionPatternType {
	if m != nil {
		return m.Type
	}
	return StepDefinitionPatternType_CUCUMBER_EXPRESSION
}

type ParameterTypeConfig struct {
	Name                            string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	RegularExpressions              []string `protobuf:"bytes,2,rep,name=regularExpressions" json:"regularExpressions,omitempty"`
	PreferForRegularExpressionMatch bool     `protobuf:"varint,3,opt,name=preferForRegularExpressionMatch,proto3" json:"preferForRegularExpressionMatch,omitempty"`
	UseForSnippets                  bool     `protobuf:"varint,4,opt,name=useForSnippets,proto3" json:"useForSnippets,omitempty"`
}

func (m *ParameterTypeConfig) Reset()         { *m = ParameterTypeConfig{} }
func (m *ParameterTypeConfig) String() string { return proto.CompactTextString(m) }
func (*ParameterTypeConfig) ProtoMessage()    {}
func (*ParameterTypeConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_commands_f6a80ffcac567fa6, []int{11}
}
func (m *ParameterTypeConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParameterTypeConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParameterTypeConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ParameterTypeConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParameterTypeConfig.Merge(dst, src)
}
func (m *ParameterTypeConfig) XXX_Size() int {
	return m.Size()
}
func (m *ParameterTypeConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ParameterTypeConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ParameterTypeConfig proto.InternalMessageInfo

func (m *ParameterTypeConfig) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ParameterTypeConfig) GetRegularExpressions() []string {
	if m != nil {
		return m.RegularExpressions
	}
	return nil
}

func (m *ParameterTypeConfig) GetPreferForRegularExpressionMatch() bool {
	if m != nil {
		return m.PreferForRegularExpressionMatch
	}
	return false
}

func (m *ParameterTypeConfig) GetUseForSnippets() bool {
	if m != nil {
		return m.UseForSnippets
	}
	return false
}

type CommandActionComplete struct {
	CompletedId string `protobuf:"bytes,1,opt,name=completedId,proto3" json:"completedId,omitempty"`
	// Types that are valid to be assigned to Result:
	//	*CommandActionComplete_TestResult
	//	*CommandActionComplete_Snippet
	Result isCommandActionComplete_Result `protobuf_oneof:"result"`
}

func (m *CommandActionComplete) Reset()         { *m = CommandActionComplete{} }
func (m *CommandActionComplete) String() string { return proto.CompactTextString(m) }
func (*CommandActionComplete) ProtoMessage()    {}
func (*CommandActionComplete) Descriptor() ([]byte, []int) {
	return fileDescriptor_commands_f6a80ffcac567fa6, []int{12}
}
func (m *CommandActionComplete) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandActionComplete) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandActionComplete.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CommandActionComplete) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandActionComplete.Merge(dst, src)
}
func (m *CommandActionComplete) XXX_Size() int {
	return m.Size()
}
func (m *CommandActionComplete) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandActionComplete.DiscardUnknown(m)
}

var xxx_messageInfo_CommandActionComplete proto.InternalMessageInfo

type isCommandActionComplete_Result interface {
	isCommandActionComplete_Result()
	MarshalTo([]byte) (int, error)
	Size() int
}

type CommandActionComplete_TestResult struct {
	TestResult *TestResult `protobuf:"bytes,2,opt,name=testResult,oneof"`
}
type CommandActionComplete_Snippet struct {
	Snippet string `protobuf:"bytes,3,opt,name=snippet,proto3,oneof"`
}

func (*CommandActionComplete_TestResult) isCommandActionComplete_Result() {}
func (*CommandActionComplete_Snippet) isCommandActionComplete_Result()    {}

func (m *CommandActionComplete) GetResult() isCommandActionComplete_Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *CommandActionComplete) GetCompletedId() string {
	if m != nil {
		return m.CompletedId
	}
	return ""
}

func (m *CommandActionComplete) GetTestResult() *TestResult {
	if x, ok := m.GetResult().(*CommandActionComplete_TestResult); ok {
		return x.TestResult
	}
	return nil
}

func (m *CommandActionComplete) GetSnippet() string {
	if x, ok := m.GetResult().(*CommandActionComplete_Snippet); ok {
		return x.Snippet
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CommandActionComplete) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CommandActionComplete_OneofMarshaler, _CommandActionComplete_OneofUnmarshaler, _CommandActionComplete_OneofSizer, []interface{}{
		(*CommandActionComplete_TestResult)(nil),
		(*CommandActionComplete_Snippet)(nil),
	}
}

func _CommandActionComplete_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CommandActionComplete)
	// result
	switch x := m.Result.(type) {
	case *CommandActionComplete_TestResult:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TestResult); err != nil {
			return err
		}
	case *CommandActionComplete_Snippet:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Snippet)
	case nil:
	default:
		return fmt.Errorf("CommandActionComplete.Result has unexpected type %T", x)
	}
	return nil
}

func _CommandActionComplete_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CommandActionComplete)
	switch tag {
	case 2: // result.testResult
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TestResult)
		err := b.DecodeMessage(msg)
		m.Result = &CommandActionComplete_TestResult{msg}
		return true, err
	case 3: // result.snippet
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Result = &CommandActionComplete_Snippet{x}
		return true, err
	default:
		return false, nil
	}
}

func _CommandActionComplete_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CommandActionComplete)
	// result
	switch x := m.Result.(type) {
	case *CommandActionComplete_TestResult:
		s := proto.Size(x.TestResult)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CommandActionComplete_Snippet:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Snippet)))
		n += len(x.Snippet)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type CommandRunBeforeTestRunHooks struct {
}

func (m *CommandRunBeforeTestRunHooks) Reset()         { *m = CommandRunBeforeTestRunHooks{} }
func (m *CommandRunBeforeTestRunHooks) String() string { return proto.CompactTextString(m) }
func (*CommandRunBeforeTestRunHooks) ProtoMessage()    {}
func (*CommandRunBeforeTestRunHooks) Descriptor() ([]byte, []int) {
	return fileDescriptor_commands_f6a80ffcac567fa6, []int{13}
}
func (m *CommandRunBeforeTestRunHooks) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandRunBeforeTestRunHooks) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandRunBeforeTestRunHooks.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CommandRunBeforeTestRunHooks) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandRunBeforeTestRunHooks.Merge(dst, src)
}
func (m *CommandRunBeforeTestRunHooks) XXX_Size() int {
	return m.Size()
}
func (m *CommandRunBeforeTestRunHooks) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandRunBeforeTestRunHooks.DiscardUnknown(m)
}

var xxx_messageInfo_CommandRunBeforeTestRunHooks proto.InternalMessageInfo

type CommandRunAfterTestRunHooks struct {
}

func (m *CommandRunAfterTestRunHooks) Reset()         { *m = CommandRunAfterTestRunHooks{} }
func (m *CommandRunAfterTestRunHooks) String() string { return proto.CompactTextString(m) }
func (*CommandRunAfterTestRunHooks) ProtoMessage()    {}
func (*CommandRunAfterTestRunHooks) Descriptor() ([]byte, []int) {
	return fileDescriptor_commands_f6a80ffcac567fa6, []int{14}
}
func (m *CommandRunAfterTestRunHooks) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandRunAfterTestRunHooks) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandRunAfterTestRunHooks.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CommandRunAfterTestRunHooks) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandRunAfterTestRunHooks.Merge(dst, src)
}
func (m *CommandRunAfterTestRunHooks) XXX_Size() int {
	return m.Size()
}
func (m *CommandRunAfterTestRunHooks) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandRunAfterTestRunHooks.DiscardUnknown(m)
}

var xxx_messageInfo_CommandRunAfterTestRunHooks proto.InternalMessageInfo

type CommandInitializeTestCase struct {
	TestCaseId string  `protobuf:"bytes,1,opt,name=testCaseId,proto3" json:"testCaseId,omitempty"`
	Pickle     *Pickle `protobuf:"bytes,2,opt,name=pickle" json:"pickle,omitempty"`
}

func (m *CommandInitializeTestCase) Reset()         { *m = CommandInitializeTestCase{} }
func (m *CommandInitializeTestCase) String() string { return proto.CompactTextString(m) }
func (*CommandInitializeTestCase) ProtoMessage()    {}
func (*CommandInitializeTestCase) Descriptor() ([]byte, []int) {
	return fileDescriptor_commands_f6a80ffcac567fa6, []int{15}
}
func (m *CommandInitializeTestCase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandInitializeTestCase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandInitializeTestCase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CommandInitializeTestCase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandInitializeTestCase.Merge(dst, src)
}
func (m *CommandInitializeTestCase) XXX_Size() int {
	return m.Size()
}
func (m *CommandInitializeTestCase) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandInitializeTestCase.DiscardUnknown(m)
}

var xxx_messageInfo_CommandInitializeTestCase proto.InternalMessageInfo

func (m *CommandInitializeTestCase) GetTestCaseId() string {
	if m != nil {
		return m.TestCaseId
	}
	return ""
}

func (m *CommandInitializeTestCase) GetPickle() *Pickle {
	if m != nil {
		return m.Pickle
	}
	return nil
}

type CommandRunBeforeTestCaseHook struct {
	TestCaseId               string `protobuf:"bytes,1,opt,name=testCaseId,proto3" json:"testCaseId,omitempty"`
	TestCaseHookDefinitionId string `protobuf:"bytes,2,opt,name=testCaseHookDefinitionId,proto3" json:"testCaseHookDefinitionId,omitempty"`
}

func (m *CommandRunBeforeTestCaseHook) Reset()         { *m = CommandRunBeforeTestCaseHook{} }
func (m *CommandRunBeforeTestCaseHook) String() string { return proto.CompactTextString(m) }
func (*CommandRunBeforeTestCaseHook) ProtoMessage()    {}
func (*CommandRunBeforeTestCaseHook) Descriptor() ([]byte, []int) {
	return fileDescriptor_commands_f6a80ffcac567fa6, []int{16}
}
func (m *CommandRunBeforeTestCaseHook) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandRunBeforeTestCaseHook) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandRunBeforeTestCaseHook.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CommandRunBeforeTestCaseHook) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandRunBeforeTestCaseHook.Merge(dst, src)
}
func (m *CommandRunBeforeTestCaseHook) XXX_Size() int {
	return m.Size()
}
func (m *CommandRunBeforeTestCaseHook) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandRunBeforeTestCaseHook.DiscardUnknown(m)
}

var xxx_messageInfo_CommandRunBeforeTestCaseHook proto.InternalMessageInfo

func (m *CommandRunBeforeTestCaseHook) GetTestCaseId() string {
	if m != nil {
		return m.TestCaseId
	}
	return ""
}

func (m *CommandRunBeforeTestCaseHook) GetTestCaseHookDefinitionId() string {
	if m != nil {
		return m.TestCaseHookDefinitionId
	}
	return ""
}

type CommandRunAfterTestCaseHook struct {
	TestCaseId               string `protobuf:"bytes,1,opt,name=testCaseId,proto3" json:"testCaseId,omitempty"`
	TestCaseHookDefinitionId string `protobuf:"bytes,2,opt,name=testCaseHookDefinitionId,proto3" json:"testCaseHookDefinitionId,omitempty"`
}

func (m *CommandRunAfterTestCaseHook) Reset()         { *m = CommandRunAfterTestCaseHook{} }
func (m *CommandRunAfterTestCaseHook) String() string { return proto.CompactTextString(m) }
func (*CommandRunAfterTestCaseHook) ProtoMessage()    {}
func (*CommandRunAfterTestCaseHook) Descriptor() ([]byte, []int) {
	return fileDescriptor_commands_f6a80ffcac567fa6, []int{17}
}
func (m *CommandRunAfterTestCaseHook) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandRunAfterTestCaseHook) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandRunAfterTestCaseHook.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CommandRunAfterTestCaseHook) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandRunAfterTestCaseHook.Merge(dst, src)
}
func (m *CommandRunAfterTestCaseHook) XXX_Size() int {
	return m.Size()
}
func (m *CommandRunAfterTestCaseHook) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandRunAfterTestCaseHook.DiscardUnknown(m)
}

var xxx_messageInfo_CommandRunAfterTestCaseHook proto.InternalMessageInfo

func (m *CommandRunAfterTestCaseHook) GetTestCaseId() string {
	if m != nil {
		return m.TestCaseId
	}
	return ""
}

func (m *CommandRunAfterTestCaseHook) GetTestCaseHookDefinitionId() string {
	if m != nil {
		return m.TestCaseHookDefinitionId
	}
	return ""
}

type CommandRunTestStep struct {
	TestCaseId       string          `protobuf:"bytes,1,opt,name=testCaseId,proto3" json:"testCaseId,omitempty"`
	StepDefinitionId string          `protobuf:"bytes,2,opt,name=stepDefinitionId,proto3" json:"stepDefinitionId,omitempty"`
	PatternMatches   []*PatternMatch `protobuf:"bytes,3,rep,name=patternMatches" json:"patternMatches,omitempty"`
}

func (m *CommandRunTestStep) Reset()         { *m = CommandRunTestStep{} }
func (m *CommandRunTestStep) String() string { return proto.CompactTextString(m) }
func (*CommandRunTestStep) ProtoMessage()    {}
func (*CommandRunTestStep) Descriptor() ([]byte, []int) {
	return fileDescriptor_commands_f6a80ffcac567fa6, []int{18}
}
func (m *CommandRunTestStep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandRunTestStep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandRunTestStep.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CommandRunTestStep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandRunTestStep.Merge(dst, src)
}
func (m *CommandRunTestStep) XXX_Size() int {
	return m.Size()
}
func (m *CommandRunTestStep) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandRunTestStep.DiscardUnknown(m)
}

var xxx_messageInfo_CommandRunTestStep proto.InternalMessageInfo

func (m *CommandRunTestStep) GetTestCaseId() string {
	if m != nil {
		return m.TestCaseId
	}
	return ""
}

func (m *CommandRunTestStep) GetStepDefinitionId() string {
	if m != nil {
		return m.StepDefinitionId
	}
	return ""
}

func (m *CommandRunTestStep) GetPatternMatches() []*PatternMatch {
	if m != nil {
		return m.PatternMatches
	}
	return nil
}

type PatternMatch struct {
	Captures          []string `protobuf:"bytes,1,rep,name=captures" json:"captures,omitempty"`
	ParameterTypeName string   `protobuf:"bytes,2,opt,name=parameterTypeName,proto3" json:"parameterTypeName,omitempty"`
	// Types that are valid to be assigned to PickleArgument:
	//	*PatternMatch_DocString
	//	*PatternMatch_DataTable
	PickleArgument isPatternMatch_PickleArgument `protobuf_oneof:"pickleArgument"`
}

func (m *PatternMatch) Reset()         { *m = PatternMatch{} }
func (m *PatternMatch) String() string { return proto.CompactTextString(m) }
func (*PatternMatch) ProtoMessage()    {}
func (*PatternMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_commands_f6a80ffcac567fa6, []int{19}
}
func (m *PatternMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PatternMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PatternMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PatternMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PatternMatch.Merge(dst, src)
}
func (m *PatternMatch) XXX_Size() int {
	return m.Size()
}
func (m *PatternMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_PatternMatch.DiscardUnknown(m)
}

var xxx_messageInfo_PatternMatch proto.InternalMessageInfo

type isPatternMatch_PickleArgument interface {
	isPatternMatch_PickleArgument()
	MarshalTo([]byte) (int, error)
	Size() int
}

type PatternMatch_DocString struct {
	DocString *PickleDocString `protobuf:"bytes,3,opt,name=doc_string,json=docString,oneof"`
}
type PatternMatch_DataTable struct {
	DataTable *PickleTable `protobuf:"bytes,4,opt,name=data_table,json=dataTable,oneof"`
}

func (*PatternMatch_DocString) isPatternMatch_PickleArgument() {}
func (*PatternMatch_DataTable) isPatternMatch_PickleArgument() {}

func (m *PatternMatch) GetPickleArgument() isPatternMatch_PickleArgument {
	if m != nil {
		return m.PickleArgument
	}
	return nil
}

func (m *PatternMatch) GetCaptures() []string {
	if m != nil {
		return m.Captures
	}
	return nil
}

func (m *PatternMatch) GetParameterTypeName() string {
	if m != nil {
		return m.ParameterTypeName
	}
	return ""
}

func (m *PatternMatch) GetDocString() *PickleDocString {
	if x, ok := m.GetPickleArgument().(*PatternMatch_DocString); ok {
		return x.DocString
	}
	return nil
}

func (m *PatternMatch) GetDataTable() *PickleTable {
	if x, ok := m.GetPickleArgument().(*PatternMatch_DataTable); ok {
		return x.DataTable
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PatternMatch) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PatternMatch_OneofMarshaler, _PatternMatch_OneofUnmarshaler, _PatternMatch_OneofSizer, []interface{}{
		(*PatternMatch_DocString)(nil),
		(*PatternMatch_DataTable)(nil),
	}
}

func _PatternMatch_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PatternMatch)
	// pickleArgument
	switch x := m.PickleArgument.(type) {
	case *PatternMatch_DocString:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DocString); err != nil {
			return err
		}
	case *PatternMatch_DataTable:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DataTable); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("PatternMatch.PickleArgument has unexpected type %T", x)
	}
	return nil
}

func _PatternMatch_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PatternMatch)
	switch tag {
	case 3: // pickleArgument.doc_string
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PickleDocString)
		err := b.DecodeMessage(msg)
		m.PickleArgument = &PatternMatch_DocString{msg}
		return true, err
	case 4: // pickleArgument.data_table
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PickleTable)
		err := b.DecodeMessage(msg)
		m.PickleArgument = &PatternMatch_DataTable{msg}
		return true, err
	default:
		return false, nil
	}
}

func _PatternMatch_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PatternMatch)
	// pickleArgument
	switch x := m.PickleArgument.(type) {
	case *PatternMatch_DocString:
		s := proto.Size(x.DocString)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PatternMatch_DataTable:
		s := proto.Size(x.DataTable)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type CommandGenerateSnippet struct {
	GeneratedExpressions []*GeneratedExpression `protobuf:"bytes,1,rep,name=generatedExpressions" json:"generatedExpressions,omitempty"`
	// Types that are valid to be assigned to PickleArgument:
	//	*CommandGenerateSnippet_DocString
	//	*CommandGenerateSnippet_DataTable
	PickleArgument isCommandGenerateSnippet_PickleArgument `protobuf_oneof:"pickleArgument"`
}

func (m *CommandGenerateSnippet) Reset()         { *m = CommandGenerateSnippet{} }
func (m *CommandGenerateSnippet) String() string { return proto.CompactTextString(m) }
func (*CommandGenerateSnippet) ProtoMessage()    {}
func (*CommandGenerateSnippet) Descriptor() ([]byte, []int) {
	return fileDescriptor_commands_f6a80ffcac567fa6, []int{20}
}
func (m *CommandGenerateSnippet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandGenerateSnippet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandGenerateSnippet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CommandGenerateSnippet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandGenerateSnippet.Merge(dst, src)
}
func (m *CommandGenerateSnippet) XXX_Size() int {
	return m.Size()
}
func (m *CommandGenerateSnippet) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandGenerateSnippet.DiscardUnknown(m)
}

var xxx_messageInfo_CommandGenerateSnippet proto.InternalMessageInfo

type isCommandGenerateSnippet_PickleArgument interface {
	isCommandGenerateSnippet_PickleArgument()
	MarshalTo([]byte) (int, error)
	Size() int
}

type CommandGenerateSnippet_DocString struct {
	DocString *PickleDocString `protobuf:"bytes,2,opt,name=doc_string,json=docString,oneof"`
}
type CommandGenerateSnippet_DataTable struct {
	DataTable *PickleTable `protobuf:"bytes,3,opt,name=data_table,json=dataTable,oneof"`
}

func (*CommandGenerateSnippet_DocString) isCommandGenerateSnippet_PickleArgument() {}
func (*CommandGenerateSnippet_DataTable) isCommandGenerateSnippet_PickleArgument() {}

func (m *CommandGenerateSnippet) GetPickleArgument() isCommandGenerateSnippet_PickleArgument {
	if m != nil {
		return m.PickleArgument
	}
	return nil
}

func (m *CommandGenerateSnippet) GetGeneratedExpressions() []*GeneratedExpression {
	if m != nil {
		return m.GeneratedExpressions
	}
	return nil
}

func (m *CommandGenerateSnippet) GetDocString() *PickleDocString {
	if x, ok := m.GetPickleArgument().(*CommandGenerateSnippet_DocString); ok {
		return x.DocString
	}
	return nil
}

func (m *CommandGenerateSnippet) GetDataTable() *PickleTable {
	if x, ok := m.GetPickleArgument().(*CommandGenerateSnippet_DataTable); ok {
		return x.DataTable
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CommandGenerateSnippet) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CommandGenerateSnippet_OneofMarshaler, _CommandGenerateSnippet_OneofUnmarshaler, _CommandGenerateSnippet_OneofSizer, []interface{}{
		(*CommandGenerateSnippet_DocString)(nil),
		(*CommandGenerateSnippet_DataTable)(nil),
	}
}

func _CommandGenerateSnippet_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CommandGenerateSnippet)
	// pickleArgument
	switch x := m.PickleArgument.(type) {
	case *CommandGenerateSnippet_DocString:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DocString); err != nil {
			return err
		}
	case *CommandGenerateSnippet_DataTable:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DataTable); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CommandGenerateSnippet.PickleArgument has unexpected type %T", x)
	}
	return nil
}

func _CommandGenerateSnippet_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CommandGenerateSnippet)
	switch tag {
	case 2: // pickleArgument.doc_string
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PickleDocString)
		err := b.DecodeMessage(msg)
		m.PickleArgument = &CommandGenerateSnippet_DocString{msg}
		return true, err
	case 3: // pickleArgument.data_table
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PickleTable)
		err := b.DecodeMessage(msg)
		m.PickleArgument = &CommandGenerateSnippet_DataTable{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CommandGenerateSnippet_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CommandGenerateSnippet)
	// pickleArgument
	switch x := m.PickleArgument.(type) {
	case *CommandGenerateSnippet_DocString:
		s := proto.Size(x.DocString)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CommandGenerateSnippet_DataTable:
		s := proto.Size(x.DataTable)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type GeneratedExpression struct {
	Text               string   `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	ParameterTypeNames []string `protobuf:"bytes,2,rep,name=parameterTypeNames" json:"parameterTypeNames,omitempty"`
}

func (m *GeneratedExpression) Reset()         { *m = GeneratedExpression{} }
func (m *GeneratedExpression) String() string { return proto.CompactTextString(m) }
func (*GeneratedExpression) ProtoMessage()    {}
func (*GeneratedExpression) Descriptor() ([]byte, []int) {
	return fileDescriptor_commands_f6a80ffcac567fa6, []int{21}
}
func (m *GeneratedExpression) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GeneratedExpression) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GeneratedExpression.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GeneratedExpression) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GeneratedExpression.Merge(dst, src)
}
func (m *GeneratedExpression) XXX_Size() int {
	return m.Size()
}
func (m *GeneratedExpression) XXX_DiscardUnknown() {
	xxx_messageInfo_GeneratedExpression.DiscardUnknown(m)
}

var xxx_messageInfo_GeneratedExpression proto.InternalMessageInfo

func (m *GeneratedExpression) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *GeneratedExpression) GetParameterTypeNames() []string {
	if m != nil {
		return m.ParameterTypeNames
	}
	return nil
}

func init() {
	proto.RegisterType((*CommandWrapper)(nil), "io.cucumber.messages.CommandWrapper")
	proto.RegisterType((*CommandStart)(nil), "io.cucumber.messages.CommandStart")
	proto.RegisterType((*FeaturesConfig)(nil), "io.cucumber.messages.FeaturesConfig")
	proto.RegisterType((*FeaturesFilterConfig)(nil), "io.cucumber.messages.FeaturesFilterConfig")
	proto.RegisterType((*UriToLinesMapping)(nil), "io.cucumber.messages.UriToLinesMapping")
	proto.RegisterType((*FeaturesOrder)(nil), "io.cucumber.messages.FeaturesOrder")
	proto.RegisterType((*RuntimeConfig)(nil), "io.cucumber.messages.RuntimeConfig")
	proto.RegisterType((*SupportCodeConfig)(nil), "io.cucumber.messages.SupportCodeConfig")
	proto.RegisterType((*TestCaseHookDefinitionConfig)(nil), "io.cucumber.messages.TestCaseHookDefinitionConfig")
	proto.RegisterType((*StepDefinitionConfig)(nil), "io.cucumber.messages.StepDefinitionConfig")
	proto.RegisterType((*StepDefinitionPattern)(nil), "io.cucumber.messages.StepDefinitionPattern")
	proto.RegisterType((*ParameterTypeConfig)(nil), "io.cucumber.messages.ParameterTypeConfig")
	proto.RegisterType((*CommandActionComplete)(nil), "io.cucumber.messages.CommandActionComplete")
	proto.RegisterType((*CommandRunBeforeTestRunHooks)(nil), "io.cucumber.messages.CommandRunBeforeTestRunHooks")
	proto.RegisterType((*CommandRunAfterTestRunHooks)(nil), "io.cucumber.messages.CommandRunAfterTestRunHooks")
	proto.RegisterType((*CommandInitializeTestCase)(nil), "io.cucumber.messages.CommandInitializeTestCase")
	proto.RegisterType((*CommandRunBeforeTestCaseHook)(nil), "io.cucumber.messages.CommandRunBeforeTestCaseHook")
	proto.RegisterType((*CommandRunAfterTestCaseHook)(nil), "io.cucumber.messages.CommandRunAfterTestCaseHook")
	proto.RegisterType((*CommandRunTestStep)(nil), "io.cucumber.messages.CommandRunTestStep")
	proto.RegisterType((*PatternMatch)(nil), "io.cucumber.messages.PatternMatch")
	proto.RegisterType((*CommandGenerateSnippet)(nil), "io.cucumber.messages.CommandGenerateSnippet")
	proto.RegisterType((*GeneratedExpression)(nil), "io.cucumber.messages.GeneratedExpression")
	proto.RegisterEnum("io.cucumber.messages.FeaturesOrderType", FeaturesOrderType_name, FeaturesOrderType_value)
	proto.RegisterEnum("io.cucumber.messages.StepDefinitionPatternType", StepDefinitionPatternType_name, StepDefinitionPatternType_value)
}
func (m *CommandWrapper) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandWrapper) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommands(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Message != nil {
		nn1, err := m.Message.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *CommandWrapper_CommandStart) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CommandStart != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommands(dAtA, i, uint64(m.CommandStart.Size()))
		n2, err := m.CommandStart.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *CommandWrapper_CommandActionComplete) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CommandActionComplete != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommands(dAtA, i, uint64(m.CommandActionComplete.Size()))
		n3, err := m.CommandActionComplete.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *CommandWrapper_CommandRunBeforeTestRunHooks) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CommandRunBeforeTestRunHooks != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCommands(dAtA, i, uint64(m.CommandRunBeforeTestRunHooks.Size()))
		n4, err := m.CommandRunBeforeTestRunHooks.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *CommandWrapper_CommandInitializeTestCase) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CommandInitializeTestCase != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCommands(dAtA, i, uint64(m.CommandInitializeTestCase.Size()))
		n5, err := m.CommandInitializeTestCase.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *CommandWrapper_CommandRunBeforeTestCaseHook) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CommandRunBeforeTestCaseHook != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCommands(dAtA, i, uint64(m.CommandRunBeforeTestCaseHook.Size()))
		n6, err := m.CommandRunBeforeTestCaseHook.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *CommandWrapper_CommandRunTestStep) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CommandRunTestStep != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCommands(dAtA, i, uint64(m.CommandRunTestStep.Size()))
		n7, err := m.CommandRunTestStep.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *CommandWrapper_CommandRunAfterTestCaseHook) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CommandRunAfterTestCaseHook != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCommands(dAtA, i, uint64(m.CommandRunAfterTestCaseHook.Size()))
		n8, err := m.CommandRunAfterTestCaseHook.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *CommandWrapper_CommandRunAfterTestRunHooks) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CommandRunAfterTestRunHooks != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintCommands(dAtA, i, uint64(m.CommandRunAfterTestRunHooks.Size()))
		n9, err := m.CommandRunAfterTestRunHooks.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *CommandWrapper_CommandGenerateSnippet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CommandGenerateSnippet != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintCommands(dAtA, i, uint64(m.CommandGenerateSnippet.Size()))
		n10, err := m.CommandGenerateSnippet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *CommandWrapper_CommandEvent) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CommandEvent != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintCommands(dAtA, i, uint64(m.CommandEvent.Size()))
		n11, err := m.CommandEvent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *CommandWrapper_CommandError) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x62
	i++
	i = encodeVarintCommands(dAtA, i, uint64(len(m.CommandError)))
	i += copy(dAtA[i:], m.CommandError)
	return i, nil
}
func (m *CommandStart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandStart) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BaseDirectory) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommands(dAtA, i, uint64(len(m.BaseDirectory)))
		i += copy(dAtA[i:], m.BaseDirectory)
	}
	if m.FeaturesConfig != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommands(dAtA, i, uint64(m.FeaturesConfig.Size()))
		n12, err := m.FeaturesConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.RuntimeConfig != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCommands(dAtA, i, uint64(m.RuntimeConfig.Size()))
		n13, err := m.RuntimeConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.SupportCodeConfig != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCommands(dAtA, i, uint64(m.SupportCodeConfig.Size()))
		n14, err := m.SupportCodeConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *FeaturesConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeaturesConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AbsolutePaths) > 0 {
		for _, s := range m.AbsolutePaths {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Language) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommands(dAtA, i, uint64(len(m.Language)))
		i += copy(dAtA[i:], m.Language)
	}
	if m.Filters != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommands(dAtA, i, uint64(m.Filters.Size()))
		n15, err := m.Filters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.Order != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCommands(dAtA, i, uint64(m.Order.Size()))
		n16, err := m.Order.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *FeaturesFilterConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeaturesFilterConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TagExpression) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommands(dAtA, i, uint64(len(m.TagExpression)))
		i += copy(dAtA[i:], m.TagExpression)
	}
	if len(m.NameRegularExpressions) > 0 {
		for _, s := range m.NameRegularExpressions {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.UriToLinesMapping) > 0 {
		for _, msg := range m.UriToLinesMapping {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCommands(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UriToLinesMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UriToLinesMapping) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AbsolutePath) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommands(dAtA, i, uint64(len(m.AbsolutePath)))
		i += copy(dAtA[i:], m.AbsolutePath)
	}
	if len(m.Lines) > 0 {
		dAtA18 := make([]byte, len(m.Lines)*10)
		var j17 int
		for _, num := range m.Lines {
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommands(dAtA, i, uint64(j17))
		i += copy(dAtA[i:], dAtA18[:j17])
	}
	return i, nil
}

func (m *FeaturesOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeaturesOrder) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommands(dAtA, i, uint64(m.Type))
	}
	if m.Seed != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommands(dAtA, i, uint64(m.Seed))
	}
	return i, nil
}

func (m *RuntimeConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuntimeConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsFailFast {
		dAtA[i] = 0x8
		i++
		if m.IsFailFast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsDryRun {
		dAtA[i] = 0x10
		i++
		if m.IsDryRun {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsStrict {
		dAtA[i] = 0x18
		i++
		if m.IsStrict {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MaxParallel != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommands(dAtA, i, uint64(m.MaxParallel))
	}
	return i, nil
}

func (m *SupportCodeConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SupportCodeConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BeforeTestCaseHookDefinitionConfigs) > 0 {
		for _, msg := range m.BeforeTestCaseHookDefinitionConfigs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCommands(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AfterTestCaseHookDefinitionConfigs) > 0 {
		for _, msg := range m.AfterTestCaseHookDefinitionConfigs {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCommands(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.StepDefinitionConfigs) > 0 {
		for _, msg := range m.StepDefinitionConfigs {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCommands(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ParameterTypeConfigs) > 0 {
		for _, msg := range m.ParameterTypeConfigs {
			dAtA[i] = 0x22
			i++
			i = encodeVarintCommands(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TestCaseHookDefinitionConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestCaseHookDefinitionConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommands(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.TagExpression) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommands(dAtA, i, uint64(len(m.TagExpression)))
		i += copy(dAtA[i:], m.TagExpression)
	}
	if m.Location != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommands(dAtA, i, uint64(m.Location.Size()))
		n19, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *StepDefinitionConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StepDefinitionConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommands(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Pattern != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommands(dAtA, i, uint64(m.Pattern.Size()))
		n20, err := m.Pattern.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.Location != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommands(dAtA, i, uint64(m.Location.Size()))
		n21, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}

func (m *StepDefinitionPattern) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StepDefinitionPattern) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Source) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommands(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommands(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *ParameterTypeConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParameterTypeConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommands(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.RegularExpressions) > 0 {
		for _, s := range m.RegularExpressions {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.PreferForRegularExpressionMatch {
		dAtA[i] = 0x18
		i++
		if m.PreferForRegularExpressionMatch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UseForSnippets {
		dAtA[i] = 0x20
		i++
		if m.UseForSnippets {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *CommandActionComplete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandActionComplete) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CompletedId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommands(dAtA, i, uint64(len(m.CompletedId)))
		i += copy(dAtA[i:], m.CompletedId)
	}
	if m.Result != nil {
		nn22, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn22
	}
	return i, nil
}

func (m *CommandActionComplete_TestResult) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TestResult != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommands(dAtA, i, uint64(m.TestResult.Size()))
		n23, err := m.TestResult.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}
func (m *CommandActionComplete_Snippet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCommands(dAtA, i, uint64(len(m.Snippet)))
	i += copy(dAtA[i:], m.Snippet)
	return i, nil
}
func (m *CommandRunBeforeTestRunHooks) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandRunBeforeTestRunHooks) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CommandRunAfterTestRunHooks) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandRunAfterTestRunHooks) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CommandInitializeTestCase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandInitializeTestCase) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TestCaseId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommands(dAtA, i, uint64(len(m.TestCaseId)))
		i += copy(dAtA[i:], m.TestCaseId)
	}
	if m.Pickle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommands(dAtA, i, uint64(m.Pickle.Size()))
		n24, err := m.Pickle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}

func (m *CommandRunBeforeTestCaseHook) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandRunBeforeTestCaseHook) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TestCaseId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommands(dAtA, i, uint64(len(m.TestCaseId)))
		i += copy(dAtA[i:], m.TestCaseId)
	}
	if len(m.TestCaseHookDefinitionId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommands(dAtA, i, uint64(len(m.TestCaseHookDefinitionId)))
		i += copy(dAtA[i:], m.TestCaseHookDefinitionId)
	}
	return i, nil
}

func (m *CommandRunAfterTestCaseHook) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandRunAfterTestCaseHook) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TestCaseId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommands(dAtA, i, uint64(len(m.TestCaseId)))
		i += copy(dAtA[i:], m.TestCaseId)
	}
	if len(m.TestCaseHookDefinitionId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommands(dAtA, i, uint64(len(m.TestCaseHookDefinitionId)))
		i += copy(dAtA[i:], m.TestCaseHookDefinitionId)
	}
	return i, nil
}

func (m *CommandRunTestStep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandRunTestStep) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TestCaseId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommands(dAtA, i, uint64(len(m.TestCaseId)))
		i += copy(dAtA[i:], m.TestCaseId)
	}
	if len(m.StepDefinitionId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommands(dAtA, i, uint64(len(m.StepDefinitionId)))
		i += copy(dAtA[i:], m.StepDefinitionId)
	}
	if len(m.PatternMatches) > 0 {
		for _, msg := range m.PatternMatches {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCommands(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PatternMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PatternMatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Captures) > 0 {
		for _, s := range m.Captures {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ParameterTypeName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommands(dAtA, i, uint64(len(m.ParameterTypeName)))
		i += copy(dAtA[i:], m.ParameterTypeName)
	}
	if m.PickleArgument != nil {
		nn25, err := m.PickleArgument.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn25
	}
	return i, nil
}

func (m *PatternMatch_DocString) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DocString != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommands(dAtA, i, uint64(m.DocString.Size()))
		n26, err := m.DocString.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}
func (m *PatternMatch_DataTable) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DataTable != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCommands(dAtA, i, uint64(m.DataTable.Size()))
		n27, err := m.DataTable.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}
func (m *CommandGenerateSnippet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandGenerateSnippet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GeneratedExpressions) > 0 {
		for _, msg := range m.GeneratedExpressions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCommands(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PickleArgument != nil {
		nn28, err := m.PickleArgument.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn28
	}
	return i, nil
}

func (m *CommandGenerateSnippet_DocString) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DocString != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommands(dAtA, i, uint64(m.DocString.Size()))
		n29, err := m.DocString.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}
func (m *CommandGenerateSnippet_DataTable) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DataTable != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommands(dAtA, i, uint64(m.DataTable.Size()))
		n30, err := m.DataTable.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	return i, nil
}
func (m *GeneratedExpression) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GeneratedExpression) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Text) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommands(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if len(m.ParameterTypeNames) > 0 {
		for _, s := range m.ParameterTypeNames {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func encodeVarintCommands(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CommandWrapper) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCommands(uint64(l))
	}
	if m.Message != nil {
		n += m.Message.Size()
	}
	return n
}

func (m *CommandWrapper_CommandStart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommandStart != nil {
		l = m.CommandStart.Size()
		n += 1 + l + sovCommands(uint64(l))
	}
	return n
}
func (m *CommandWrapper_CommandActionComplete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommandActionComplete != nil {
		l = m.CommandActionComplete.Size()
		n += 1 + l + sovCommands(uint64(l))
	}
	return n
}
func (m *CommandWrapper_CommandRunBeforeTestRunHooks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommandRunBeforeTestRunHooks != nil {
		l = m.CommandRunBeforeTestRunHooks.Size()
		n += 1 + l + sovCommands(uint64(l))
	}
	return n
}
func (m *CommandWrapper_CommandInitializeTestCase) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommandInitializeTestCase != nil {
		l = m.CommandInitializeTestCase.Size()
		n += 1 + l + sovCommands(uint64(l))
	}
	return n
}
func (m *CommandWrapper_CommandRunBeforeTestCaseHook) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommandRunBeforeTestCaseHook != nil {
		l = m.CommandRunBeforeTestCaseHook.Size()
		n += 1 + l + sovCommands(uint64(l))
	}
	return n
}
func (m *CommandWrapper_CommandRunTestStep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommandRunTestStep != nil {
		l = m.CommandRunTestStep.Size()
		n += 1 + l + sovCommands(uint64(l))
	}
	return n
}
func (m *CommandWrapper_CommandRunAfterTestCaseHook) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommandRunAfterTestCaseHook != nil {
		l = m.CommandRunAfterTestCaseHook.Size()
		n += 1 + l + sovCommands(uint64(l))
	}
	return n
}
func (m *CommandWrapper_CommandRunAfterTestRunHooks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommandRunAfterTestRunHooks != nil {
		l = m.CommandRunAfterTestRunHooks.Size()
		n += 1 + l + sovCommands(uint64(l))
	}
	return n
}
func (m *CommandWrapper_CommandGenerateSnippet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommandGenerateSnippet != nil {
		l = m.CommandGenerateSnippet.Size()
		n += 1 + l + sovCommands(uint64(l))
	}
	return n
}
func (m *CommandWrapper_CommandEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommandEvent != nil {
		l = m.CommandEvent.Size()
		n += 1 + l + sovCommands(uint64(l))
	}
	return n
}
func (m *CommandWrapper_CommandError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CommandError)
	n += 1 + l + sovCommands(uint64(l))
	return n
}
func (m *CommandStart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BaseDirectory)
	if l > 0 {
		n += 1 + l + sovCommands(uint64(l))
	}
	if m.FeaturesConfig != nil {
		l = m.FeaturesConfig.Size()
		n += 1 + l + sovCommands(uint64(l))
	}
	if m.RuntimeConfig != nil {
		l = m.RuntimeConfig.Size()
		n += 1 + l + sovCommands(uint64(l))
	}
	if m.SupportCodeConfig != nil {
		l = m.SupportCodeConfig.Size()
		n += 1 + l + sovCommands(uint64(l))
	}
	return n
}

func (m *FeaturesConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AbsolutePaths) > 0 {
		for _, s := range m.AbsolutePaths {
			l = len(s)
			n += 1 + l + sovCommands(uint64(l))
		}
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovCommands(uint64(l))
	}
	if m.Filters != nil {
		l = m.Filters.Size()
		n += 1 + l + sovCommands(uint64(l))
	}
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovCommands(uint64(l))
	}
	return n
}

func (m *FeaturesFilterConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TagExpression)
	if l > 0 {
		n += 1 + l + sovCommands(uint64(l))
	}
	if len(m.NameRegularExpressions) > 0 {
		for _, s := range m.NameRegularExpressions {
			l = len(s)
			n += 1 + l + sovCommands(uint64(l))
		}
	}
	if len(m.UriToLinesMapping) > 0 {
		for _, e := range m.UriToLinesMapping {
			l = e.Size()
			n += 1 + l + sovCommands(uint64(l))
		}
	}
	return n
}

func (m *UriToLinesMapping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AbsolutePath)
	if l > 0 {
		n += 1 + l + sovCommands(uint64(l))
	}
	if len(m.Lines) > 0 {
		l = 0
		for _, e := range m.Lines {
			l += sovCommands(uint64(e))
		}
		n += 1 + sovCommands(uint64(l)) + l
	}
	return n
}

func (m *FeaturesOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovCommands(uint64(m.Type))
	}
	if m.Seed != 0 {
		n += 1 + sovCommands(uint64(m.Seed))
	}
	return n
}

func (m *RuntimeConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsFailFast {
		n += 2
	}
	if m.IsDryRun {
		n += 2
	}
	if m.IsStrict {
		n += 2
	}
	if m.MaxParallel != 0 {
		n += 1 + sovCommands(uint64(m.MaxParallel))
	}
	return n
}

func (m *SupportCodeConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BeforeTestCaseHookDefinitionConfigs) > 0 {
		for _, e := range m.BeforeTestCaseHookDefinitionConfigs {
			l = e.Size()
			n += 1 + l + sovCommands(uint64(l))
		}
	}
	if len(m.AfterTestCaseHookDefinitionConfigs) > 0 {
		for _, e := range m.AfterTestCaseHookDefinitionConfigs {
			l = e.Size()
			n += 1 + l + sovCommands(uint64(l))
		}
	}
	if len(m.StepDefinitionConfigs) > 0 {
		for _, e := range m.StepDefinitionConfigs {
			l = e.Size()
			n += 1 + l + sovCommands(uint64(l))
		}
	}
	if len(m.ParameterTypeConfigs) > 0 {
		for _, e := range m.ParameterTypeConfigs {
			l = e.Size()
			n += 1 + l + sovCommands(uint64(l))
		}
	}
	return n
}

func (m *TestCaseHookDefinitionConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCommands(uint64(l))
	}
	l = len(m.TagExpression)
	if l > 0 {
		n += 1 + l + sovCommands(uint64(l))
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovCommands(uint64(l))
	}
	return n
}

func (m *StepDefinitionConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCommands(uint64(l))
	}
	if m.Pattern != nil {
		l = m.Pattern.Size()
		n += 1 + l + sovCommands(uint64(l))
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovCommands(uint64(l))
	}
	return n
}

func (m *StepDefinitionPattern) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovCommands(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovCommands(uint64(m.Type))
	}
	return n
}

func (m *ParameterTypeConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCommands(uint64(l))
	}
	if len(m.RegularExpressions) > 0 {
		for _, s := range m.RegularExpressions {
			l = len(s)
			n += 1 + l + sovCommands(uint64(l))
		}
	}
	if m.PreferForRegularExpressionMatch {
		n += 2
	}
	if m.UseForSnippets {
		n += 2
	}
	return n
}

func (m *CommandActionComplete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CompletedId)
	if l > 0 {
		n += 1 + l + sovCommands(uint64(l))
	}
	if m.Result != nil {
		n += m.Result.Size()
	}
	return n
}

func (m *CommandActionComplete_TestResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestResult != nil {
		l = m.TestResult.Size()
		n += 1 + l + sovCommands(uint64(l))
	}
	return n
}
func (m *CommandActionComplete_Snippet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Snippet)
	n += 1 + l + sovCommands(uint64(l))
	return n
}
func (m *CommandRunBeforeTestRunHooks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CommandRunAfterTestRunHooks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CommandInitializeTestCase) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TestCaseId)
	if l > 0 {
		n += 1 + l + sovCommands(uint64(l))
	}
	if m.Pickle != nil {
		l = m.Pickle.Size()
		n += 1 + l + sovCommands(uint64(l))
	}
	return n
}

func (m *CommandRunBeforeTestCaseHook) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TestCaseId)
	if l > 0 {
		n += 1 + l + sovCommands(uint64(l))
	}
	l = len(m.TestCaseHookDefinitionId)
	if l > 0 {
		n += 1 + l + sovCommands(uint64(l))
	}
	return n
}

func (m *CommandRunAfterTestCaseHook) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TestCaseId)
	if l > 0 {
		n += 1 + l + sovCommands(uint64(l))
	}
	l = len(m.TestCaseHookDefinitionId)
	if l > 0 {
		n += 1 + l + sovCommands(uint64(l))
	}
	return n
}

func (m *CommandRunTestStep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TestCaseId)
	if l > 0 {
		n += 1 + l + sovCommands(uint64(l))
	}
	l = len(m.StepDefinitionId)
	if l > 0 {
		n += 1 + l + sovCommands(uint64(l))
	}
	if len(m.PatternMatches) > 0 {
		for _, e := range m.PatternMatches {
			l = e.Size()
			n += 1 + l + sovCommands(uint64(l))
		}
	}
	return n
}

func (m *PatternMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Captures) > 0 {
		for _, s := range m.Captures {
			l = len(s)
			n += 1 + l + sovCommands(uint64(l))
		}
	}
	l = len(m.ParameterTypeName)
	if l > 0 {
		n += 1 + l + sovCommands(uint64(l))
	}
	if m.PickleArgument != nil {
		n += m.PickleArgument.Size()
	}
	return n
}

func (m *PatternMatch_DocString) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DocString != nil {
		l = m.DocString.Size()
		n += 1 + l + sovCommands(uint64(l))
	}
	return n
}
func (m *PatternMatch_DataTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataTable != nil {
		l = m.DataTable.Size()
		n += 1 + l + sovCommands(uint64(l))
	}
	return n
}
func (m *CommandGenerateSnippet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.GeneratedExpressions) > 0 {
		for _, e := range m.GeneratedExpressions {
			l = e.Size()
			n += 1 + l + sovCommands(uint64(l))
		}
	}
	if m.PickleArgument != nil {
		n += m.PickleArgument.Size()
	}
	return n
}

func (m *CommandGenerateSnippet_DocString) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DocString != nil {
		l = m.DocString.Size()
		n += 1 + l + sovCommands(uint64(l))
	}
	return n
}
func (m *CommandGenerateSnippet_DataTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataTable != nil {
		l = m.DataTable.Size()
		n += 1 + l + sovCommands(uint64(l))
	}
	return n
}
func (m *GeneratedExpression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovCommands(uint64(l))
	}
	if len(m.ParameterTypeNames) > 0 {
		for _, s := range m.ParameterTypeNames {
			l = len(s)
			n += 1 + l + sovCommands(uint64(l))
		}
	}
	return n
}

func sovCommands(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCommands(x uint64) (n int) {
	return sovCommands(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CommandWrapper) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommands
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandWrapper: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandWrapper: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandStart{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &CommandWrapper_CommandStart{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandActionComplete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandActionComplete{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &CommandWrapper_CommandActionComplete{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandRunBeforeTestRunHooks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandRunBeforeTestRunHooks{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &CommandWrapper_CommandRunBeforeTestRunHooks{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandInitializeTestCase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandInitializeTestCase{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &CommandWrapper_CommandInitializeTestCase{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandRunBeforeTestCaseHook", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandRunBeforeTestCaseHook{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &CommandWrapper_CommandRunBeforeTestCaseHook{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandRunTestStep", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandRunTestStep{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &CommandWrapper_CommandRunTestStep{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandRunAfterTestCaseHook", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandRunAfterTestCaseHook{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &CommandWrapper_CommandRunAfterTestCaseHook{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandRunAfterTestRunHooks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandRunAfterTestRunHooks{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &CommandWrapper_CommandRunAfterTestRunHooks{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandGenerateSnippet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandGenerateSnippet{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &CommandWrapper_CommandGenerateSnippet{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EventWrapper{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &CommandWrapper_CommandEvent{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = &CommandWrapper_CommandError{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommands(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommands
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandStart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommands
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandStart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandStart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseDirectory", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseDirectory = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeaturesConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FeaturesConfig == nil {
				m.FeaturesConfig = &FeaturesConfig{}
			}
			if err := m.FeaturesConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RuntimeConfig == nil {
				m.RuntimeConfig = &RuntimeConfig{}
			}
			if err := m.RuntimeConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportCodeConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SupportCodeConfig == nil {
				m.SupportCodeConfig = &SupportCodeConfig{}
			}
			if err := m.SupportCodeConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommands(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommands
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeaturesConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommands
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeaturesConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeaturesConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbsolutePaths", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AbsolutePaths = append(m.AbsolutePaths, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filters == nil {
				m.Filters = &FeaturesFilterConfig{}
			}
			if err := m.Filters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &FeaturesOrder{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommands(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommands
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeaturesFilterConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommands
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeaturesFilterConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeaturesFilterConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagExpression", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagExpression = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameRegularExpressions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameRegularExpressions = append(m.NameRegularExpressions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UriToLinesMapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UriToLinesMapping = append(m.UriToLinesMapping, &UriToLinesMapping{})
			if err := m.UriToLinesMapping[len(m.UriToLinesMapping)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommands(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommands
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UriToLinesMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommands
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UriToLinesMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UriToLinesMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbsolutePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AbsolutePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommands
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Lines = append(m.Lines, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommands
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCommands
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Lines) == 0 {
					m.Lines = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommands
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Lines = append(m.Lines, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Lines", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommands(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommands
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeaturesOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommands
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeaturesOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeaturesOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (FeaturesOrderType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seed", wireType)
			}
			m.Seed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seed |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommands(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommands
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RuntimeConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommands
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuntimeConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuntimeConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFailFast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFailFast = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDryRun", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDryRun = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsStrict", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsStrict = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxParallel", wireType)
			}
			m.MaxParallel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxParallel |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommands(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommands
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SupportCodeConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommands
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SupportCodeConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SupportCodeConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeforeTestCaseHookDefinitionConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BeforeTestCaseHookDefinitionConfigs = append(m.BeforeTestCaseHookDefinitionConfigs, &TestCaseHookDefinitionConfig{})
			if err := m.BeforeTestCaseHookDefinitionConfigs[len(m.BeforeTestCaseHookDefinitionConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AfterTestCaseHookDefinitionConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AfterTestCaseHookDefinitionConfigs = append(m.AfterTestCaseHookDefinitionConfigs, &TestCaseHookDefinitionConfig{})
			if err := m.AfterTestCaseHookDefinitionConfigs[len(m.AfterTestCaseHookDefinitionConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepDefinitionConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StepDefinitionConfigs = append(m.StepDefinitionConfigs, &StepDefinitionConfig{})
			if err := m.StepDefinitionConfigs[len(m.StepDefinitionConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParameterTypeConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParameterTypeConfigs = append(m.ParameterTypeConfigs, &ParameterTypeConfig{})
			if err := m.ParameterTypeConfigs[len(m.ParameterTypeConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommands(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommands
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestCaseHookDefinitionConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommands
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestCaseHookDefinitionConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestCaseHookDefinitionConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagExpression", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagExpression = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &SourceReference{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommands(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommands
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StepDefinitionConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommands
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StepDefinitionConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StepDefinitionConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pattern == nil {
				m.Pattern = &StepDefinitionPattern{}
			}
			if err := m.Pattern.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &SourceReference{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommands(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommands
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StepDefinitionPattern) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommands
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StepDefinitionPattern: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StepDefinitionPattern: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (StepDefinitionPatternType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommands(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommands
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParameterTypeConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommands
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParameterTypeConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParameterTypeConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegularExpressions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegularExpressions = append(m.RegularExpressions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreferForRegularExpressionMatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PreferForRegularExpressionMatch = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseForSnippets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseForSnippets = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCommands(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommands
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandActionComplete) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommands
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandActionComplete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandActionComplete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletedId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CompletedId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestResult{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Result = &CommandActionComplete_TestResult{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snippet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = &CommandActionComplete_Snippet{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommands(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommands
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandRunBeforeTestRunHooks) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommands
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandRunBeforeTestRunHooks: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandRunBeforeTestRunHooks: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCommands(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommands
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandRunAfterTestRunHooks) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommands
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandRunAfterTestRunHooks: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandRunAfterTestRunHooks: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCommands(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommands
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandInitializeTestCase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommands
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandInitializeTestCase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandInitializeTestCase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestCaseId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pickle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pickle == nil {
				m.Pickle = &Pickle{}
			}
			if err := m.Pickle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommands(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommands
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandRunBeforeTestCaseHook) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommands
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandRunBeforeTestCaseHook: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandRunBeforeTestCaseHook: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestCaseId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseHookDefinitionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestCaseHookDefinitionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommands(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommands
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandRunAfterTestCaseHook) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommands
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandRunAfterTestCaseHook: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandRunAfterTestCaseHook: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestCaseId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseHookDefinitionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestCaseHookDefinitionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommands(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommands
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandRunTestStep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommands
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandRunTestStep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandRunTestStep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestCaseId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepDefinitionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StepDefinitionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PatternMatches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PatternMatches = append(m.PatternMatches, &PatternMatch{})
			if err := m.PatternMatches[len(m.PatternMatches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommands(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommands
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PatternMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommands
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PatternMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PatternMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Captures", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Captures = append(m.Captures, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParameterTypeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParameterTypeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocString", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PickleDocString{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PickleArgument = &PatternMatch_DocString{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PickleTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PickleArgument = &PatternMatch_DataTable{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommands(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommands
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandGenerateSnippet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommands
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandGenerateSnippet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandGenerateSnippet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeneratedExpressions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GeneratedExpressions = append(m.GeneratedExpressions, &GeneratedExpression{})
			if err := m.GeneratedExpressions[len(m.GeneratedExpressions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocString", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PickleDocString{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PickleArgument = &CommandGenerateSnippet_DocString{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PickleTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PickleArgument = &CommandGenerateSnippet_DataTable{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommands(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommands
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GeneratedExpression) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommands
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GeneratedExpression: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GeneratedExpression: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParameterTypeNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommands
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParameterTypeNames = append(m.ParameterTypeNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommands(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommands
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCommands(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCommands
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommands
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCommands
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCommands
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCommands(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCommands = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCommands   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("commands.proto", fileDescriptor_commands_f6a80ffcac567fa6) }

var fileDescriptor_commands_f6a80ffcac567fa6 = []byte{
	// 1494 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x58, 0xcd, 0x6f, 0x1b, 0x37,
	0x16, 0xd7, 0xc8, 0x8e, 0x2d, 0xbf, 0xd8, 0x82, 0xcd, 0xd8, 0x5e, 0xc5, 0xf1, 0x2a, 0xde, 0x49,
	0x76, 0x37, 0xeb, 0x04, 0x36, 0x36, 0xbb, 0x08, 0xfa, 0x71, 0xb2, 0xf5, 0x11, 0xb9, 0xf0, 0x17,
	0x28, 0x1b, 0x6d, 0x03, 0x14, 0x0e, 0x3d, 0xa2, 0x94, 0x41, 0x46, 0xc3, 0x29, 0x87, 0x53, 0xd8,
	0x39, 0x16, 0xbd, 0xf4, 0xd6, 0x4b, 0xd1, 0x3f, 0xa0, 0x3d, 0xf6, 0xd0, 0x3f, 0xa3, 0x40, 0x2f,
	0x01, 0x7a, 0xe9, 0x31, 0x4d, 0x6e, 0xfd, 0x03, 0x7a, 0x2e, 0xc8, 0xe1, 0xc8, 0x33, 0x9a, 0x0f,
	0x27, 0x45, 0xd0, 0x9b, 0xf8, 0xf8, 0x7e, 0xbf, 0x47, 0xbe, 0x79, 0xfc, 0xf1, 0x51, 0x50, 0xb5,
	0xd8, 0x70, 0x48, 0xdc, 0x9e, 0xbf, 0xe1, 0x71, 0x26, 0x18, 0x5a, 0xb4, 0xd9, 0x86, 0x15, 0x58,
	0xc1, 0xf0, 0x94, 0xf2, 0x8d, 0x21, 0xf5, 0x7d, 0x32, 0xa0, 0xfe, 0xca, 0xcd, 0x01, 0x63, 0x03,
	0x87, 0x6e, 0x2a, 0x9f, 0xd3, 0xa0, 0xbf, 0x29, 0xec, 0x21, 0xf5, 0x05, 0x19, 0x7a, 0x21, 0x6c,
	0x65, 0x96, 0x7e, 0x46, 0x5d, 0xa1, 0x49, 0xcc, 0x5f, 0x2b, 0x50, 0x6d, 0x84, 0xbc, 0x1f, 0x72,
	0xe2, 0x79, 0x94, 0xa3, 0x2a, 0x94, 0xed, 0x5e, 0xcd, 0x58, 0x33, 0xee, 0xcc, 0xe0, 0xb2, 0xdd,
	0x43, 0x1d, 0x98, 0xd5, 0x91, 0xbb, 0x82, 0x70, 0x51, 0x2b, 0xaf, 0x19, 0x77, 0xae, 0xde, 0x37,
	0x37, 0xb2, 0xc2, 0x6f, 0x34, 0x62, 0x9e, 0x9d, 0x12, 0x4e, 0x20, 0x91, 0x05, 0x4b, 0x7a, 0xbc,
	0x65, 0x09, 0x9b, 0xb9, 0x0d, 0x36, 0xf4, 0x1c, 0x2a, 0x68, 0x6d, 0x42, 0x51, 0xde, 0x2d, 0xa4,
	0x4c, 0x42, 0x3a, 0x25, 0x9c, 0xcd, 0x85, 0xce, 0x60, 0x55, 0x4f, 0xe0, 0xc0, 0xdd, 0xa6, 0x7d,
	0xc6, 0xe9, 0x11, 0xf5, 0x05, 0x0e, 0xdc, 0x0e, 0x63, 0x4f, 0xfd, 0xda, 0xa4, 0x8a, 0x75, 0xbf,
	0x30, 0x56, 0x26, 0xb2, 0x53, 0xc2, 0x85, 0xcc, 0x88, 0xc1, 0x75, 0x3d, 0xbf, 0xe3, 0xda, 0xc2,
	0x26, 0x8e, 0xfd, 0x4c, 0x39, 0x34, 0x88, 0x4f, 0x6b, 0x57, 0x54, 0xd8, 0xcd, 0xc2, 0xb0, 0x69,
	0x58, 0xa7, 0x84, 0xf3, 0x39, 0xf3, 0xb6, 0xaa, 0x80, 0x8c, 0x3d, 0xad, 0x4d, 0xbd, 0xe9, 0x56,
	0x23, 0x64, 0xde, 0x56, 0xa3, 0x79, 0xf4, 0x08, 0xd0, 0xc5, 0xbc, 0x9c, 0xe9, 0x0a, 0xea, 0xd5,
	0xa6, 0x55, 0xbc, 0x3b, 0x97, 0xc5, 0x8b, 0xfc, 0x3b, 0x25, 0x9c, 0xc1, 0x82, 0x02, 0xb8, 0x71,
	0x61, 0xdd, 0xea, 0x0b, 0xca, 0x13, 0x9b, 0xaa, 0xa8, 0x20, 0xff, 0xbd, 0x2c, 0x48, 0x0a, 0xd8,
	0x29, 0xe1, 0x22, 0xde, 0x9c, 0xb0, 0xa3, 0xb2, 0x99, 0x79, 0xc3, 0xb0, 0xb1, 0xaa, 0x29, 0xe2,
	0x45, 0x7d, 0x58, 0xd6, 0xd3, 0x0f, 0xa9, 0x4b, 0x39, 0x11, 0xb4, 0xeb, 0xda, 0x9e, 0x47, 0x45,
	0x0d, 0x54, 0xc4, 0x7b, 0x85, 0x11, 0xc7, 0x30, 0x9d, 0x12, 0xce, 0x61, 0x8b, 0x9d, 0xe2, 0x96,
	0x3c, 0xff, 0xb5, 0xab, 0x45, 0xa7, 0x58, 0xb9, 0x68, 0x3d, 0x88, 0x9d, 0x62, 0x65, 0x46, 0xb7,
	0x2f, 0x98, 0x38, 0x67, 0xbc, 0x36, 0x2b, 0x95, 0x22, 0xee, 0x25, 0xad, 0xdb, 0x33, 0x30, 0xad,
	0xe9, 0xcc, 0xef, 0xca, 0x30, 0x1b, 0xd7, 0x05, 0x74, 0x1b, 0xe6, 0x4e, 0x89, 0x4f, 0x9b, 0x36,
	0xa7, 0x96, 0x60, 0xfc, 0x5c, 0x49, 0xca, 0x0c, 0x4e, 0x1a, 0xd1, 0x2e, 0x54, 0xfb, 0x94, 0x88,
	0x80, 0x53, 0xbf, 0xc1, 0xdc, 0xbe, 0x3d, 0xd0, 0x32, 0x71, 0x3b, 0x7b, 0xcd, 0xed, 0x84, 0x2f,
	0x1e, 0xc3, 0xa2, 0x1d, 0x98, 0xe3, 0x81, 0x2b, 0xc5, 0x50, 0x93, 0x85, 0x3a, 0x70, 0x2b, 0x9b,
	0x0c, 0xc7, 0x5d, 0x71, 0x12, 0x89, 0x8e, 0x61, 0xc1, 0x0f, 0x3c, 0x8f, 0x71, 0xd1, 0x60, 0xbd,
	0x88, 0x2e, 0x3c, 0xdf, 0xff, 0xce, 0xa6, 0xeb, 0x8e, 0xbb, 0xe3, 0x34, 0x83, 0xf9, 0xb3, 0x01,
	0xd5, 0xe4, 0x26, 0x64, 0xa2, 0xc8, 0xa9, 0xcf, 0x9c, 0x40, 0xd0, 0x43, 0x22, 0x9e, 0xf8, 0x35,
	0x63, 0x6d, 0x42, 0x26, 0x2a, 0x61, 0x44, 0x2b, 0x50, 0x71, 0x88, 0x3b, 0x08, 0xc8, 0x80, 0xea,
	0x4c, 0x8e, 0xc6, 0xa8, 0x09, 0xd3, 0x7d, 0xdb, 0x11, 0x94, 0xfb, 0x3a, 0x7b, 0xeb, 0xc5, 0xd9,
	0x6b, 0x2b, 0x67, 0xbd, 0xc8, 0x08, 0x8a, 0xde, 0x85, 0x2b, 0x8c, 0xf7, 0x28, 0x2f, 0x4e, 0x5a,
	0xc4, 0x71, 0x20, 0x5d, 0x71, 0x88, 0x30, 0x7f, 0x32, 0x60, 0x31, 0x8b, 0x5c, 0xee, 0x4d, 0x90,
	0x41, 0xeb, 0xcc, 0xe3, 0xd4, 0xf7, 0x6d, 0xe6, 0xea, 0x1b, 0x27, 0x69, 0x44, 0x0f, 0x60, 0xd9,
	0x25, 0x43, 0x8a, 0xe9, 0x20, 0x70, 0x08, 0xbf, 0x98, 0xf0, 0x6b, 0x65, 0x95, 0x8a, 0x9c, 0x59,
	0xf9, 0x8d, 0x02, 0x6e, 0x1f, 0xb1, 0x5d, 0xdb, 0xa5, 0xfe, 0x1e, 0xf1, 0x3c, 0xdb, 0x95, 0xf5,
	0x33, 0x91, 0xff, 0x8d, 0x8e, 0xc7, 0xdd, 0x71, 0x9a, 0xc1, 0xdc, 0x83, 0x85, 0x94, 0x1f, 0x32,
	0x61, 0x36, 0xfe, 0x41, 0xf4, 0x46, 0x12, 0x36, 0xb4, 0x08, 0x57, 0x1c, 0x89, 0x51, 0xcb, 0x9e,
	0xc4, 0xe1, 0xc0, 0x7c, 0x0c, 0x73, 0x89, 0xa4, 0xa1, 0xf7, 0x61, 0x52, 0x9c, 0x7b, 0x54, 0x51,
	0x54, 0xf3, 0x56, 0x9a, 0x80, 0x1c, 0x9d, 0x7b, 0x14, 0x2b, 0x10, 0x42, 0x30, 0xe9, 0x53, 0xda,
	0x53, 0x35, 0x30, 0x89, 0xd5, 0x6f, 0xf3, 0x4b, 0x03, 0xe6, 0x12, 0xc5, 0x8c, 0xea, 0x00, 0xb6,
	0xdf, 0x26, 0xb6, 0xd3, 0x26, 0xbe, 0x50, 0x81, 0x2a, 0x38, 0x66, 0x91, 0xd5, 0x64, 0xfb, 0x4d,
	0x7e, 0x8e, 0x03, 0x57, 0x31, 0x55, 0xf0, 0x68, 0x1c, 0xce, 0x75, 0x05, 0xb7, 0x2d, 0xa1, 0xca,
	0x49, 0xcd, 0x85, 0x63, 0xb4, 0x06, 0x57, 0x87, 0xe4, 0xec, 0x90, 0x70, 0xe2, 0x38, 0xd4, 0x51,
	0x95, 0x32, 0x89, 0xe3, 0x26, 0xf3, 0xc5, 0x04, 0x2c, 0xa4, 0x4e, 0x02, 0xfa, 0xc2, 0x80, 0x5b,
	0xa7, 0xa9, 0x1b, 0xa6, 0x49, 0xfb, 0xb6, 0xbc, 0xf0, 0xe4, 0xc5, 0x2e, 0xdd, 0xc2, 0xd2, 0xcf,
	0xbd, 0xcc, 0x8a, 0xa0, 0xf8, 0x75, 0xe8, 0xd1, 0xe7, 0x06, 0x98, 0x64, 0xfc, 0x52, 0x48, 0xaf,
	0xa2, 0xfc, 0xa7, 0x57, 0xf1, 0x1a, 0xec, 0xe8, 0x31, 0x2c, 0xf9, 0x82, 0x7a, 0xe9, 0xb0, 0x61,
	0xe5, 0xe6, 0x9c, 0xdd, 0x6e, 0x06, 0x04, 0x67, 0x13, 0xa1, 0x4f, 0x60, 0xd1, 0x23, 0x9c, 0x0c,
	0xa9, 0x08, 0x4b, 0x27, 0x0a, 0x30, 0xa9, 0x02, 0xfc, 0x27, 0x3b, 0xc0, 0x61, 0x1a, 0x81, 0x33,
	0x69, 0xcc, 0x6f, 0x0c, 0x58, 0x2d, 0xda, 0x62, 0xaa, 0xb9, 0x4c, 0xa9, 0x40, 0x39, 0x4b, 0x05,
	0xb6, 0xa0, 0xe2, 0x30, 0x8b, 0x48, 0x1e, 0x2d, 0x63, 0xff, 0xcc, 0x49, 0x05, 0x0b, 0xb8, 0x45,
	0x31, 0xed, 0x53, 0x4e, 0x5d, 0x8b, 0xe2, 0x11, 0xcc, 0xfc, 0xc1, 0x80, 0xc5, 0xac, 0x44, 0xa5,
	0x56, 0xd4, 0x82, 0x69, 0x8f, 0x08, 0x41, 0xb9, 0xab, 0x3b, 0xdd, 0xbb, 0xaf, 0x93, 0xf5, 0xc3,
	0x10, 0x82, 0x23, 0xec, 0xdb, 0x58, 0xb2, 0x80, 0xa5, 0xcc, 0x20, 0x68, 0x19, 0xa6, 0x7c, 0x85,
	0xd2, 0xcb, 0xd6, 0x23, 0xd4, 0xd0, 0xea, 0x51, 0x56, 0xea, 0xb1, 0xf9, 0x06, 0xeb, 0xbe, 0x50,
	0x11, 0x29, 0xd8, 0xd7, 0x32, 0x3e, 0xb8, 0x54, 0x17, 0xa9, 0xb5, 0x3a, 0xa4, 0xfa, 0x8d, 0x36,
	0x00, 0xf1, 0x3c, 0x65, 0xce, 0x98, 0x41, 0x1d, 0xb8, 0xe9, 0x71, 0xb9, 0xd3, 0x36, 0xe3, 0x29,
	0xd1, 0xde, 0x23, 0xc2, 0x7a, 0xa2, 0x65, 0xe5, 0x32, 0x37, 0xf4, 0x2f, 0xa8, 0x06, 0x3e, 0x6d,
	0x33, 0xae, 0xfb, 0x9b, 0xb0, 0xaf, 0xaf, 0xe0, 0x31, 0xab, 0xf9, 0xad, 0x01, 0x4b, 0x99, 0x0f,
	0x08, 0xa9, 0x57, 0x96, 0xfe, 0xdd, 0xdb, 0x89, 0x0a, 0x20, 0x6e, 0x42, 0xdb, 0x00, 0x42, 0xb6,
	0x6a, 0xd4, 0x0f, 0x9c, 0xe8, 0xd9, 0xb3, 0x96, 0x7f, 0xf2, 0x43, 0xbf, 0x4e, 0x09, 0xc7, 0x50,
	0x68, 0x05, 0xa6, 0x7d, 0xdd, 0xcf, 0x4d, 0xe8, 0x3e, 0x29, 0x32, 0x6c, 0x57, 0x60, 0x8a, 0x2b,
	0x2f, 0xb3, 0x0e, 0xab, 0x45, 0x2f, 0x0f, 0xf3, 0xef, 0x70, 0xa3, 0xa0, 0xc5, 0x34, 0x3f, 0x85,
	0xeb, 0xb9, 0x2f, 0x08, 0xa9, 0xf7, 0x42, 0xff, 0x1e, 0x6d, 0x33, 0x66, 0x41, 0xff, 0x87, 0x29,
	0xcf, 0xb6, 0x9e, 0x3a, 0x54, 0xef, 0x70, 0x35, 0x47, 0x03, 0x94, 0x0f, 0xd6, 0xbe, 0xe6, 0xb3,
	0xec, 0x15, 0x8f, 0xba, 0xe9, 0xcb, 0xa2, 0xbe, 0x07, 0x35, 0x91, 0xa9, 0x13, 0x3b, 0x3d, 0x2d,
	0x01, 0xb9, 0xf3, 0xe6, 0x79, 0x66, 0x36, 0xfe, 0x92, 0xd0, 0xdf, 0x1b, 0x80, 0xd2, 0x0f, 0x99,
	0x4b, 0x43, 0xae, 0xc3, 0x7c, 0x52, 0x8e, 0x47, 0xa1, 0x52, 0x76, 0xf4, 0x01, 0x54, 0xb5, 0x86,
	0xa8, 0x4a, 0xa7, 0x91, 0xf8, 0x9b, 0x79, 0xda, 0x7c, 0xe1, 0x8b, 0xc7, 0x90, 0xe6, 0xef, 0x06,
	0xcc, 0xc6, 0x1d, 0xe4, 0x05, 0x6e, 0x11, 0x4f, 0x75, 0x0f, 0xba, 0x97, 0x1c, 0x8d, 0xd1, 0x3d,
	0x58, 0x48, 0x68, 0xfa, 0xbe, 0x3c, 0xed, 0xe1, 0x2a, 0xd3, 0x13, 0xa8, 0x0d, 0xd0, 0x63, 0xd6,
	0x89, 0x2f, 0x78, 0xd8, 0x59, 0x15, 0x28, 0x5c, 0x58, 0x3a, 0x4d, 0x66, 0x75, 0x95, 0x73, 0xa7,
	0x84, 0x67, 0x7a, 0xd1, 0x40, 0x1e, 0xb2, 0x1e, 0x11, 0xe4, 0x44, 0x90, 0x53, 0x87, 0xea, 0xfe,
	0xf2, 0x1f, 0x45, 0x3c, 0x47, 0xd2, 0x51, 0x71, 0x10, 0x41, 0xd4, 0x60, 0x7b, 0x1e, 0xaa, 0x61,
	0x59, 0x6e, 0xf1, 0x41, 0x30, 0xa4, 0xae, 0x30, 0xbf, 0x2e, 0xc3, 0x72, 0xf6, 0x13, 0x49, 0xde,
	0x80, 0x03, 0x6d, 0xea, 0xc5, 0x55, 0xcb, 0x28, 0xba, 0x01, 0x1f, 0xa6, 0x11, 0x38, 0x93, 0x66,
	0x2c, 0x2f, 0xe5, 0xb7, 0x94, 0x97, 0x89, 0xb7, 0x94, 0x97, 0x8f, 0xe1, 0x5a, 0xc6, 0x56, 0xa4,
	0xb6, 0x0b, 0x7a, 0x26, 0x22, 0x6d, 0x97, 0xbf, 0xa5, 0xb6, 0xa7, 0xbe, 0xfa, 0x48, 0xdb, 0xd3,
	0x33, 0xeb, 0xef, 0xc0, 0x42, 0xaa, 0x31, 0x45, 0x7f, 0x83, 0x6b, 0x07, 0xb8, 0xd9, 0xc2, 0x27,
	0x07, 0xed, 0x93, 0x66, 0xab, 0xbd, 0xb3, 0xbf, 0x73, 0xb4, 0x73, 0xb0, 0x3f, 0x5f, 0x42, 0x00,
	0x53, 0x78, 0x6b, 0xbf, 0x79, 0xb0, 0x37, 0x6f, 0xac, 0xef, 0xc2, 0xf5, 0xdc, 0x4b, 0x49, 0x32,
	0x34, 0x8e, 0x1b, 0xc7, 0x7b, 0xdb, 0x2d, 0x7c, 0xd2, 0xfa, 0xe8, 0x10, 0xb7, 0xba, 0xdd, 0x90,
	0x61, 0x19, 0x10, 0x6e, 0x3d, 0x3c, 0xde, 0xdd, 0x4a, 0xd8, 0x8d, 0xed, 0x07, 0x3f, 0xbe, 0xac,
	0x1b, 0xcf, 0x5f, 0xd6, 0x8d, 0x17, 0x2f, 0xeb, 0xc6, 0x57, 0xaf, 0xea, 0xa5, 0xe7, 0xaf, 0xea,
	0xa5, 0x5f, 0x5e, 0xd5, 0x4b, 0x8f, 0x2a, 0x51, 0xc6, 0x7e, 0x2b, 0x2f, 0x34, 0xa2, 0x2c, 0xee,
	0x69, 0xdb, 0xe9, 0x94, 0xfa, 0x43, 0xec, 0x7f, 0x7f, 0x04, 0x00, 0x00, 0xff, 0xff, 0x55, 0xfb,
	0x08, 0xfc, 0x67, 0x13, 0x00, 0x00,
}
